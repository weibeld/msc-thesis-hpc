<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <title>GOAL Help</title>
  <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
  <meta name="AppleTitle" content="GOAL Help" />
  <link rel="stylesheet" type="text/css" href="style.css" />
</head>

<body>

<!-- ================== Introduction ================== -->

<!--
<div id="toc">
  <div id="tocheader">Table of Contents</div>
  <div id="toclist">
    <ul>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#editors">Editors</a></li>
      <li><a href="#menu">Menu Items</a></li>
      <li><a href="#cmd">Command-Line Mode</a></li>
      <li><a href="#extending_goal">Extending GOAL</a></li>
      <li><a href="#terminology">Terminology</a></li>
      <li><a href="#references">References</a></li>
    </ul>
  </div>
</div>
-->

<div class="plain">

<h1 class="nopadding"><a name="introduction">Introduction</a></h1>

<p class="plain">
GOAL [<a href="#references:tct07">TCT+07</a>,
<a href="#references:tct08">TCT+08</a>, <a href="#references:tth13">TTH13</a>]
is a graphical interactive tool for
defining and manipulating &omega;-automata and temporal logic formulae.
The GOAL tool can be used for educational purposes, helping the user get a
better understanding of how &omega;-automata work and how they are related
to linear temporal logics.

It may also be used to construct correct and smaller specification automata,
supplementing model checkers such as
<a href="http://www.spinroot.com/">SPIN</a> that adopt the automata-theoretic
approach.

Most functions can be accessed by programs or scripts, making GOAL convenient
for supporting research.
</p>

<p class="plain">
The acronym GOAL was originally derived from &ldquo;Graphical Tool for
Omega-Automata and Logics&rdquo;.

It also stands for &ldquo;Games, Omega-Automata, and Logics&rdquo;, as we
gradually add support for omega-regular games.
Our long-term goal is for the tool to handle all the common variants of
&omega;-automata and the logics that are expressively equivalent to these
automata.

Therefore, the GOAL tool will constantly be extended and improved.
</p>

<p class="plain">
Quick links: 
<a href="#goal_windows">GOAL Windows</a>,
<a href="#editors">Editors</a>,
<a href="#menu">Menu Items</a>,
<a href="#cmd">Command-Line Mode</a> (<a href="#cmd:commands">commands</a>),
<a href="#extending_goal">Extending GOAL</a>,
<a href="#terminology">Terminology</a>,
<a href="#references">References</a>
</p>

<!-- ================== GOAL Windows ================== -->

<h1><a name="goal_windows">GOAL Windows</a></h1>

<p class="plain">
A GOAL window is a tabbed window with extensible
<a href="#editors">editors</a>, <a href="#menu">menu items</a>,
and toolbar items.
</p>

<div class="figure">
  <a href="images/GOALWindow.png">
    <img src="images/GOALWindow_s.png" border="0" alt="GOAL Window" />
  </a>
  <div class="caption">GOAL window
  </div>
</div>

<h2>Common Toolbar Items</h2>

<dl>
<dt><img src="images/NewDocument.png" alt="New Document" /></dt>
<dd>Create a new object.</dd>
<dt><img src="images/OpenFile.png" alt="Open File" /></dt>
<dd>Open a file.</dd>
<dt><img src="images/Save.png" alt="Save" /></dt>
<dd>Save the active object.</dd>
<dt><img src="images/SaveAs.png" alt="Save As..." /></dt>
<dd>Save the active object to a specified file in a specified format.</dd>
<dt><img src="images/CloseTab.png" alt="Close Tab" /></dt>
<dd>Close the active tab.</dd>
<dt><img src="images/RandomFSA.png" alt="Random FSA" /></dt>
<dd>Create a randomly generated finite state automaton.</dd>
<dt><img src="images/RandomQPTL.png" alt="Random QPTL" /></dt>
<dd>Create a randomly generated QPTL formula.</dd>
</dl>

<!-- ================== Editors ================== -->

<h1><a name="editors">Editors</a></h1>

<p class="plain">
Editors are used to define logic formulae, such as temporal formulae, and
automata, such as finite state automata, alternating automata, or games.
Once a logic formula, an automaton, or a game has been defined, it can be
manipulated by the functions included in the <a href="#menu">menu items</a>
that are accessible from the menu bar of a GOAL window.
</p>

<p class="plain">
In the default installation, there are editors for the following objects:
<a href="#editors:re">Regular Expression</a>,
<a href="#editors:ore">ω-Regular Expression</a>,
<a href="#editors:qptl">QPTL Formula</a>,
<a href="#editors:actl">ACTL Formula</a>,
<a href="#editors:automaton">Automaton</a>,
<a href="#editors:alternating_automaton">Alternating Automaton</a>, 
<a href="#editors:two_way_alternating_automaton">Two-Way Alternating Automaton</a>, and
<a href="#editors:game">Game</a>.
</p>

<h2><a name="editors:re">Regular Expression</a></h2>

<div class="figure">
  <a href="images/RegularExpressionEditor.png">
    <img src="images/RegularExpressionEditor_s.png" border="0" alt="Regular Expression Editor" />
  </a>
  <div class="caption">
  Regular expression editor
  </div>
</div>

<p class="plain">
A regular expression can be empty (&phi;, denoted by E), an empty string
(&epsilon;, denoted by &epsilon;, e or epsilon), a symbol, a concatenation
(denoted by spaces) of two regular expressions, a union (denoted by |) of two
regular expressions, or the Kleene star (denoted by *) of a regular expression.
The Kleene cross (denoted by +) is defined as <code>a<sup>+</sup> &equiv;
a a<sup>*</sup></code> while the zero or one occurrence (denoted by ?)
is defined as <code>a? &equiv; e|a</code>.
</p>

<dl>
<dt>Operators</dt>
<dd>
  <table class="decorated" border="2" cellpadding="5" cellspacing="0">
    <tr class="header">
      <th></th>
      <th>Format</th>
    </tr>
    <tr class="row1">
      <th align="right">Concatenation</th>
      <td align="center">a b</td>
    </tr>
    <tr class="row2">
      <th align="right">Alternation</th>
      <td align="center">a | b</td>
    </tr>
    <tr class="row2">
      <th align="right">Kleene Star</th>
      <td align="center">a*</td>
    </tr>
    <tr class="row2">
      <th align="right">Kleene Cross</th>
      <td align="center">a+</td>
    </tr>
    <tr class="row2">
      <th align="right">Zero or One</th>
      <td align="center">a?</td>
    </tr>
  </table>
</dd>
</dl>

<h2><a name="editors:ore">ω-Regular Expression</a></h2>

<div class="figure">
  <a href="images/OmegaRegularExpressionEditor.png">
    <img src="images/OmegaRegularExpressionEditor_s.png" border="0" alt="ω-Regular Expression Editor" />
  </a>
  <div class="caption">
    ω-regular expression editor
  </div>
</div>

<p class="plain">
An &omega;-regular expression is the union of simple &omega;-regular
expressions, which are of the form <code>u v<sup>&omega;</sup></code>,
represented by <code>u { v }</code> in GOAL, where <code>u</code> is a regular
expression and <code>v</code> is a regular expression containing no empty string.
</p>

<h2><a name="editors:qptl">QPTL Formula</a></h2>

<p class="plain">
The editor for <a href="#terminology:qptl">QPTL</a> is just a single-line text
editing field.
</p>

<div class="figure">
  <a href="images/QPTLEditor.png">
    <img src="images/QPTLEditor_s.png" border="0" alt="QPTL Editor" />
  </a>
  <div class="caption">
  QPTL editor
  </div>
</div>

<p class="plain">
The QPTL is first advocated by Sistla in 1983.
A QPTL formula is a <a href="#terminology:ptl">PTL</a> formula with
propositional quantifiers.
PTL here refers to the pure propositional version of linear temporal logic
(<a href="#terminology:ltl">LTL</a>) as defined in Manna and Pnueli's book
[<a href="#references:mp92">MP92</a>].
Currently GOAL can handle a subset of the full QPTL formulae, namely those with
quantifiers that do not fall in the scope of temporal operators.
This subset is as expressive as the full set of QPTL formulae
[<a href="#references:gpss80">GPSS80</a>,
<a href="#references:gab87">Gab87</a>].
To avoid excessive parentheses, every operator has a corresponding precedence.
</p>

<h3>Syntax</h3>

<p class="plain">
▪ &equiv; ~ │ () │ &lt;&gt; │ [] │ (-) │ (~) │ &lt;-&gt; │ [-]
<br/><br/>
▫ &equiv; /\ │ \/ │ --&gt; │ &lt;--&gt; │ U │ W │ R │ S │ B │ T
<br/><br/>
&phi; &equiv; AP │ ▪ &phi; │ &phi; ▫ &phi; │ E AP : &phi; │ A AP : &phi; 
<br/><br/>
where AP is a set of atomic propositions.
</p>

<dl>
<dt>Quantifiers</dt>
<dd>
  <table class="decorated" border="2" cellpadding="5" cellspacing="0">
    <tr class="header">
      <th></th>
      <th>Format</th>
    </tr>
    <tr class="row1">
      <th align="right">Universal</th>
      <td align="center">A</td>
    </tr>
    <tr class="row2">
      <th align="right">Existential</th>
      <td align="center">E</td>
    </tr>
  </table>
</dd>

<dt>Boolean Operators</dt>
<dd>
  <table class="decorated" border="2" cellpadding="5" cellspacing="0">
    <tr class="header">
      <th></th>
      <th>Format 1</th>
      <th>Format 2</th>
    </tr>
    <tr class="row1">
      <th align="right">Negation</th>
      <td align="center">~</td>
      <td align="center">!</td>
    </tr>
    <tr class="row2">
      <th align="right">Conjunction</th>
      <td align="center">/\</td>
      <td align="center">&amp;, &amp;&amp;</td>
    </tr>
    <tr class="row1">
      <th align="right">Disjunction</th>
      <td align="center">\/</td>
      <td align="center">|, ||</td>
    </tr>
    <tr class="row2">
      <th align="right">Implication</th>
      <td align="center">--&gt;</td>
      <td align="center">-&gt;</td>
    </tr>
    <tr class="row1">
      <th align="right">Equivalence</th>
      <td align="center">&lt;--&gt;</td>
      <td align="center">&lt;-&gt;</td>
    </tr>
  </table>
</dd>

<dt>Future Temporal Operators</dt>
<dd>
  <table class="decorated" border="2" cellpadding="5" cellspacing="0">
    <tr class="header">
      <th></th>
      <th>Format 1</th>
      <th>Format 2</th>
    </tr>
    <tr class="row1">
      <th align="right">Next</th>
      <td align="center">()</td>
      <td align="center">X</td>
    </tr>
    <tr class="row2">
      <th align="right">Eventually (Sometime)</th>
      <td align="center">&lt;&gt;</td>
      <td align="center">F</td>
    </tr>
    <tr class="row1">
      <th align="right">Henceforth (Always)</th>
      <td align="center">[]</td>
      <td align="center">G</td>
    </tr>
    <tr class="row2">
      <th align="right">Wait-for (Unless)</th>
      <td align="center">W</td>
      <td align="center">&nbsp;</td>
    </tr>
    <tr class="row1">
      <th align="right">Until</th>
      <td align="center">U</td>
      <td align="center">&nbsp;</td>
    </tr>
    <tr class="row2">
      <th align="right">Release</th>
      <td align="center">R</td>
      <td align="center">V</td>
    </tr>
  </table>
</dd>

<dt>Past Temporal Operators</dt>
<dd>
  <table class="decorated" border="2" cellpadding="5" cellspacing="0">
    <tr class="header">
      <th></th>
      <th>Format 1</th>
      <th>Format 2</th>
    </tr>
    <tr class="row1">
      <th align="right">Previous</th>
      <td align="center">(-)</td>
      <td align="center">Y</td>
    </tr>
    <tr class="row2">
      <th align="right">Before</th>
      <td align="center">(~)</td>
      <td align="center">Z</td>
    </tr>
    <tr class="row1">
      <th align="right">Once</th>
      <td align="center">&lt;-&gt;</td>
      <td align="center">O</td>
    </tr>
    <tr class="row2">
      <th align="right">So-for</th>
      <td align="center">[-]</td>
      <td align="center">H</td>
    </tr>
    <tr class="row1">
      <th align="right">Since</th>
      <td align="center">S</td>
      <td align="center">&nbsp;</td>
    </tr>
    <tr class="row2">
      <th align="right">Back-to</th>
      <td align="center">B</td>
      <td align="center">&nbsp;</td>
    </tr>
    <tr class="row2">
      <th align="right">Trigger</th>
      <td align="center">T</td>
      <td align="center">&nbsp;</td>
    </tr>
  </table>
</dd>
</dl>

Spaces are required to separate unary temporal operators in format 2 except GF and FG.
For example, X G p is equivalent to () [] p and GF p is equivalent to [] &lt;&gt; p while
both XGp and GFp are atomic propositions. All the boolean and temporal operators are
right-associative. Thus, p U q U r is equivalent to p U (q U r).

<p class="plain">
For quantifications, GOAL allows the following shorthands:
</p>
<ul>
  <li>A x : E y : f(x,y) &equiv; A x E y : f(x,y)</li>
  <li>E x E y : f(x, y) &equiv; E x y : f(x,y)</li>
</ul>

<p class="plain">
GOAL assumes the following binding precedence:
</p>
<pre>Unary Operators &gt; Temporal Binary Operators &gt; Conjunction &gt; Disjunction &gt; Implication &gt; Equivalence &gt; Quantification</pre>

<h3>Examples</h3>

<ul type="disc">
  <li>&lt;&gt; p   or F p</li>
  <li>[]&lt;&gt; p   or G F p or G (F p)</li>
  <li>[](p --&gt; &lt;&gt; q)   or G (p --&gt; F q) or G (p --&gt; (F q))</li>
  <li>[](p --&gt; &lt;-&gt; q)   or G (p --&gt; O q) or G (p --&gt; (O q))</li>
  <li>[](~p \/ ()q)   or G (~p \/ X q) or G (~p \/ (X q))</li>
  <li>[] p S q   or G p S q or (G p) S q</li>
  <li>[] (p --&gt; p S q)   or G (p --&gt; p S q) or G (p --&gt; (p S q))</li>
  <li>E t : t /\ [] ((t --&gt; p) /\ (t &lt;--&gt; () (~ t)))</li>
</ul>

<h3><a name="editors:qptl:step_by_step">Step-by-Step Translation</a></h3>

<p class="plain">
A QPTL formula can be step-by-step translated into an equivalent
automaton by various translation algorithms.
The step-by-step translation is controlled by additional toolbar items
with a read-only automaton editor and a message panel.
</p>

<div class="figure">
  <a href="images/QPTLStepByStepTranslation.png">
    <img src="images/QPTLStepByStepTranslation_s.png"
         border="0"
         alt="Step-by-Step QPTL Translation" />
  </a>
  <div class="caption">
    Step-by-step QPTL translation
  </div>
</div>

<p class="plain">
  The toolbar items used to control the translation algorithm are listed below.
</p>
<dl>
<dt><img src="images/NextStep.gif" alt="Next Step" /></dt>
<dd>Perform a minor step.</dd>
<dt><img src="images/NextStage.gif" alt="Next Stage" /></dt>
<dd>Perform a major step. A major step may contain several minor steps.</dd>
<dt><img src="images/Start.gif" alt="Start" /></dt>
<dd>
  Play the translation algorithm.
  A minor step will be performed automatically after every user-defined
  time interval.
</dd>
<dt><img src="images/Stop.gif" alt="Stop" /></dt>
<dd>Pause the process invoked by <img src="images/Start.gif" alt="Start" />.</dd>
<dt><img src="images/Interval.png" alt="Interval" /></dt>
<dd>Set the time interval (in seconds) between every two successive
steps in the process invoked by <img src="images/Start.gif" alt="Start" />.</dd>
</dl>

<h2><a name="editors:actl">ACTL Formula</a></h2>

<p class="plain">
The editor for <a href="#terminology:actl">ACTL</a> is just a single-line text
editing field.
</p>

<div class="figure">
  <a href="images/ACTLEditor.png">
    <img src="images/ACTLEditor_s.png" border="0" alt="ACTL Editor" />
  </a>
  <div class="caption">
  ACTL editor
  </div>
</div>

<p class="plain">
ACTL is a fragment of CTL where paths can only be quantified by &forall;. 
This fragment is first identified in [<a href="#references:gl94">GL94</a>] for
modular verification. 
</p>

<h3>Syntax</h3>

<p class="plain">
&psi; &equiv; AP │ ~ &psi; │ &psi; /\ &psi; │ &psi; \/ &psi; │ &psi; --&gt; &psi; │ &psi; &lt;--&gt; &psi;
<br/><br/>
&phi; &equiv; &psi; │ &phi; /\ &phi; │ &phi; \/ &phi; │ AX &phi; │ AF &phi; │ AG &phi; │ A(&phi; U &phi;) │ A(&phi; R &phi;)
<br/><br/>
where AP is a set of atomic propositions.
</p>

<dl>
<dt>Boolean Operators</dt>
<dd>
  <table class="decorated" border="2" cellpadding="5" cellspacing="0">
    <tr class="header">
      <th></th>
      <th>Format 1</th>
      <th>Format 2</th>
    </tr>
    <tr class="row1">
      <th align="right">Negation</th>
      <td align="center">~</td>
      <td align="center">!</td>
    </tr>
    <tr class="row2">
      <th align="right">Conjunction</th>
      <td align="center">/\</td>
      <td align="center">&amp;</td>
    </tr>
    <tr class="row1">
      <th align="right">Disjunction</th>
      <td align="center">\/</td>
      <td align="center">|</td>
    </tr>
    <tr class="row2">
      <th align="right">Implication</th>
      <td align="center">--&gt;</td>
      <td align="center">-&gt;</td>
    </tr>
    <tr class="row1">
      <th align="right">Equivalence</th>
      <td align="center">&lt;--&gt;</td>
      <td align="center">&lt;-&gt;</td>
    </tr>
  </table>
</dd>

<dt>Temporal Operators</dt>
<dd>
  <table class="decorated" border="2" cellpadding="5" cellspacing="0">
    <tr class="header">
      <th></th>
      <th>Format 1</th>
      <th>Format 2</th>
    </tr>
    <tr class="row1">
      <th align="right">Next</th>
      <td align="center">AX</td>
      <td align="center">&nbsp;</td>
    </tr>
    <tr class="row2">
      <th align="right">Eventually (Sometime)</th>
      <td align="center">AF</td>
      <td align="center">&nbsp;</td>
    </tr>
    <tr class="row1">
      <th align="right">Henceforth (Always)</th>
      <td align="center">AG</td>
      <td align="center">&nbsp;</td>
    </tr>
    <tr class="row1">
      <th align="right">Until</th>
      <td align="center">A(&phi; U &psi;)</td>
      <td align="center">&nbsp;</td>
    </tr>
    <tr class="row2">
      <th align="right">Release</th>
      <td align="center">A(&phi; R &psi;)</td>
      <td align="center">A(&phi; V &psi;)</td>
    </tr>
  </table>
</dd>
</dl>

<p class="plain">
GOAL assumes the following binding precedence:
</p>
<pre>Unary Operators = Temporal Operators &gt; Conjunction &gt; Disjunction &gt; Implication &gt; Equivalence</pre>

<h3>Examples</h3>

<ul type="disc">
  <li>AX p \/ AX q</li>
  <li>AG AF p</li>
</ul>

<h2><a name="editors:automaton">Finite State Automaton</a></h2>

<p class="plain">
This class includes classic finite word automata (NFW or NFA), B&uuml;chi
automata (NBW or BA), co-B&uuml;chi automata (NCW), generalized B&uuml;chi
automata (NGBW or GBA), Muller automata (NMW), Rabin automata (NRW), Streett
automata (NSW), parity automata (NPW), transition B&uuml;chi automata
(NTBW or TBA), transition generalized B&uuml;chi automata (NTGBW or TGBA),
transition Muller automata (NTMW), transition Rabin automata (NTRW), transition
Streett automata (NTSW) and transition parity automata (NTPW).
</p>

<div class="figure">
  <a href="images/AutomatonEditor.png">
    <img src="images/AutomatonEditor_s.png" border="0" alt="Automaton Editor" />
  </a>
  <div class="caption">
    Automaton editor
  </div>
</div>

<h3><a name="editors:automaton:toolbar_items">Toolbar Items</a></h3>

<dl>
<dt><img src="images/Arrow.png" alt="Arrow" /></dt>
<dd>Select states, move states, change the transition curvature, and double
click on a transition to edit its label.</dd>
<dt><img src="images/CircleState.png" alt="Circle State" /></dt>
<dd>Click on the editor to create a new automaton state.</dd>
<dt><img src="images/Transition.png" alt="Transition" /></dt>
<dd>Click on a state s, hold on the left mouse button, and release on another
state t to create a transition from s to t.
When the left mouse button is released, a text field will appear to edit the
label of the transition to be created.
The label must be a valid symbol in the alphabet of the automaton.
If the symbol does not exist in the alphabet, GOAL will try to expand the
alphabet automatically for the user.
There are two types of alphabet.
  <ol>
  <li>
    <b><a name="editors:automaton:propositional_alphabet">Propositional
    Alphabet</a></b> - A propositional symbol is represented by a string,
    consisting of blank-separated strings (literals),  that encodes a truth
    assignment to the atomic propositions appearing in the intended temporal
    formula.
    For temporal formulae with two atomic propositions p and q, the alphabet
    will be {p q, p ~q, ~p q, ~p ~q}, where "p q", "p ~q", "~p q", and "~p ~q"
    are the four "symbols" encoding all four possible truth assignments.
    The symbol "p ~q", for instance, encodes the truth assignment that p is
    true and q is false.
    A transition labled with a partially specified symbol "p" will be treated
    as two transitions labeled respectively with "p q" and "p ~q".
    The order in which the propositional literals appear is immaterial, but
    they must be separated by a blank space. 
  </li>
  <li>
    <b>Classical Alphabet</b> - A classical symbol is represented by a
    character string without blank spaces.
    For example, the alphabet may be {stop, go, turn}, where "stop", "go", and
    "turn" are the three symbols.
  </li>
  </ol>
</dd>
<dt><img src="images/Delete.png" alt="Delete" /></dt>
<dd>Click on a state, a transition label, or some state of the selected states
to delete the state, the transition, or all the selected states.</dd>
<dt>
  <a name="editors:automaton:toolbar:acc">
    <img src="images/Acc.png" border="0" alt="Acceptance Condition" />
  </a>
</dt>
<dd>
  Open the acceptance condition editor.
  When this toolbar item is enabled and an acceptance set in the accetpance
  condition editor is selected, click on a state to insert/remove it to/from
  the selected acceptance set.
  For B&uuml;chi acceptance condition, there is only one acceptance set and
  thus it is automatically selected.  
  <div class="figure">
    <img src="images/AcceptanceConditionEditor.png"
         alt="Acceptance Condition Editor" />
    <div class="caption">
      Acceptance condition and winning condition editor
    </div>
  </div>
  The buttons in the acceptance condition editor are listed below.
  <ul>
    <li>
      <img src="images/ToggleAcc.png" alt="Toggle Accepting" /> - 
      Toggle a state in/out the selected acceptance set.
    </li>
    <li>
      <img src="images/AddAcc.png" alt="Add to Acceptance" /> -
      Insert a new acceptance set or acceptance pair.
    </li>
    <li>
      <img src="images/RemoveAcc.png" alt="Remove from Acceptance" /> -
      Remove an acceptance set or acceptance pair.
    </li>
    <li>
      <img src="images/MoveAccUp.png" alt="Move Acceptance Set (Pair) Up" /> -
      Move an acceptance set or acceptance pair up.
    </li>
    <li>
      <img src="images/MoveAccDown.png" alt="Move Acceptance Set (Pair) Down" /> -
      Move an acceptance set or acceptance pair down.
    </li>
  </ul>
</dd>
<dt><img src="images/Focus.png" alt="Focus" /></dt>
<dd>
  Click on a state to focus on it and its neighbors.
  Other states will become transparent.
  The incoming transitions and the outgoing transitions of the focused state
  will be drawn in different colors.<br/>
  <div class="figure">
    <img src="images/FocusToolSnapshot.png"
         border="0"
         alt="Snapshot of Focus Tool" />
    <div class="caption">
      Effect of the focus tool
    </div>
  </div>
</dd>
<dt><img src="images/Color.png" alt="Color" /></dt>
<dd>
  Click on a state or a transition to change its color.
</dd>
</dl>

<h3><a name="editors:automaton:popup">Popup Menu Items</a></h3>

Whenever the right mouse button is clicked inside an automaton editor,
a popup menu will appear.
Whenever the right mouse button is clicked on a state, a transition, or
a set of selected states and transitions, some items in the popup menu
will become enabled to adjust properties of states and transitions.

<ul>
  <li>
    <b>Initial State</b> - Checked if the selected state is an initial
    state.
  </li>
  <li>
    <b>Final State</b> - Checked if the selected state is a final state in
    a two-way alternating automaton.
  </li>
  <li>
    <b>State Attributes</b> - Choose the attributes to be shown below a state.
  </li>
  <li>
    <b>State Name</b> - Specify how to show the name of a state.
    There are four options.
    <ul>
      <li><b>Custom Name</b> - Display the state name specified by the user.
      If there is no such name, display an initial state prefix followed by
      the state ID.</li>
      <li><b>Initial + ID</b> - Display an initial state prefix followed by
      the state ID.</li>
      <li><b>ID</b> - Display the state ID.</li>
      <li><b>None</b> - Display nothing.</li>
    </ul>
  </li>
  <li>
    <b>Reorder States</b> - Reorder state IDs by a
    <a href="#terminology:dfs">DFS</a>.
  </li>
  <li><b>Alignment</b> - Align the selected states.</li>
  <li>
    <b>Full Transition Display</b> - Checked if the transition symbols are
    not simplified.
    When the transition symbols are simplified, GOAL will, for example,
    use a transition labeled with "p" to represent two transitions labeled
    with "p q" and "p ~q" for an automaton with a
    <a href="#editors:automaton:propositional_alphabet">propositional
    alphabet</a> {p q, p ~q, ~p q, ~p ~q}.
  </li>
  <li><b>Transition Attributes</b> - Choose the attribute to be shown on
  a transition.</li>
  <li><b>Reset All Curves</b> - Reset the curature of all transitions.</li>
  <li><b>Direction</b> - Set the direction of a transition in a two-way
  alternating automaton.</li>
  <li><b>Player</b> - Change the owner player of a game state.</li>
  <li><b>Color</b> - Change the fill color of a state or the line color of a
  transition.</li>
  <li><b>Text Color</b> - Change the text color.</li>
  <li><b>Opacity</b> - Set the opacity of selected states and transitions.</li>
  <li>
    <b>Layout</b> - Lay out an automaton by various layou algorithms.
    See <a href="#menu:automaton:layout">here</a> for more details.
  </li>
  <li>
    <b>Properties</b> - Open a dialog to edit the properties of a selected
    state, a selected transition, or an automaton.
    <div class="figure">
      <img src="images/StatePropertyEditor.png" alt="State Property Editor" />
      &nbsp; &nbsp; &nbsp;
      <a href="images/AutomatonPropertyEditor.png">
        <img src="images/AutomatonPropertyEditor_s.png"
             border="0"
             alt="Automaton Property Editor" />
      </a>
      <div class="caption">
        Property editor for various objects
      </div>
    </div>
  </li>
</ul>



<h2><a name="editors:alternating_automaton">Alternating Automaton</a></h2>

<p class="plain">
The standard presentation of an alternating automaton contains
universal-states and existential-states.
In GOAL, a universal-state is represented by a box node, while an
existential-state is represented by a circle node.
GOAL only supports alternating automata in disjunctive normal form (DNF) and
conjunctive normal form (CNF).
For an alternating automaton in DNF, an existential-state can have transitions
with labels to universal-states and existential-states, while a universal-state
can only have transitions without any label to existential-states.
For example, below is an NABW equivalent to "[]&lt;&gt; p".
When a "~p" is consumed in state s0, the successors will be {s0, s1}.
</p>
<div class="figure">
  <img src="images/AlternatingAutomaton.png" border="0" alt="Alternating Automaton" />
</div>
<p class="plain">
Similarly, for an alternating automaton in CNF, a universal-state can have
transitions with labels to universal-states and existential-states, while an
existential-state can only have transitions without any label to
universal-states.
</p>

<h3>Toolbar Items</h3>

<dl>
<dt><img src="images/Arrow.png" alt="Arrow" /></dt>
<dd>
  See also the <a href="#editors:automaton:toolbar_items">toolbar items</a>
  for finite state automata.
</dd>
<dt><img src="images/CircleState.png" alt="Circle State" /></dt>
<dd>
  Click on the editor to create a new existential-state in a DNF alternating
  automaton.
</dd>
<dt><img src="images/SquareConnector.png" alt="Square Connector" /></dt>
<dd>
  Click on the editor to create a new universal-state in a DNF alternating
  automaton.
</dd>
<dt><img src="images/SquareState.png" alt="Square State" /></dt>
<dd>
  Click on the editor to create a new universal-state in a CNF alternating
  automaton.
</dd>
<dt><img src="images/CircleConnector.png" alt="Circle Connector" /></dt>
<dd>
  Click on the editor to create a new existential-state in a CNF alternating
  automaton.
</dd>
<dt><img src="images/Transition.png" alt="Transition" /></dt>
<dd>
  See also the <a href="#editors:automaton:toolbar_items">toolbar items</a>
  for finite state automata.
</dd>
<dt><img src="images/Delete.png" alt="Delete" /></dt>
<dd>
  See also the <a href="#editors:automaton:toolbar_items">toolbar items</a>
  for finite state automata.
</dd>
<dt><img src="images/Acc.png" alt="Acceptance Condition" /></dt>
<dd>
  See also the <a href="#editors:automaton:toolbar_items">toolbar items</a>
  for finite state automata.
</dd>
<dt><img src="images/Focus.png" alt="Focus" /></dt>
<dd>
  See also the <a href="#editors:automaton:toolbar_items">toolbar items</a>
  for finite state automata.
</dd>
<dt><img src="images/Color.png" alt="Color" /></dt>
<dd>
  See also the <a href="#editors:automaton:toolbar_items">toolbar items</a>
  for finite state automata.
</dd>
</dl>



<h2><a name="editors:two_way_alternating_automaton">Two-Way Alternating Automaton</a></h2>

<p class="plain">
In a two-way alternating automaton, after reading a symbol w<sub>i</sub> in a
word w<sub>0</sub> w<sub>i</sub> &hellip; w<sub>i-1</sub> w<sub>i</sub>
w<sub>i+1</sub> &hellip;, the next symbol to be read can be w<sub>i-1</sub> or
w<sub>i+1</sub>.  Thus, a node in the run tree of a two-way alternating
automaton remembers not only the current state in the automaton but also a
position in the word indicating which symbol is to be read.  If the position in
a node is <code>i</code>, then the position in its children may be
<code>i+1</code> or <code>i-1</code>. (The children may have different
positions.) 
</p>

<p class="plain">
A two-way alternating automaton in GOAL may have the following three different
types of transitions:
</p>
<ul>
  <li>A (forward) transition with a solid line: The position is incremented by
  1.</li>
  <li>A (backward) transition with a dashed line: The position is decremented
  by 1.</li>
  <li>A transition with a dotted line: This transition actually represents two
  transitions with the same symbol, one with a solid line and the other with a
  dashed line.</li>
</ul>

<div class="figure">
  <img src="images/TwoWayAlternatingAutomaton.png" border="0" alt="Two-Way Alternating Automaton" />
</div>

<h3>Toolbar Items</h3>

The toolbar items of the editor for two-way alternating automata are the same
as those of the editor for alternating automata.  The type of a transition can
be changed in the popup menu of the transition. 


<h2><a name="editors:game">Game</a></h2>

GOAL only supports two-player games.
The states owned by player 0 are represented by circle nodes, while the states
owned by player 1 are represented by box nodes. 

<div class="tip">The player of a game state can be changed in the popup menu.</div>

<h3>Toolbar Items</h3>

<dl>
<dt><img src="images/Arrow.png" alt="Arrow" /></dt>
<dd>
  See also the <a href="#editors:automaton:toolbar_items">toolbar items</a>
  for finite state automata.
</dd>
<dt><img src="images/CircleState.png" alt="Circle State" /></dt>
<dd>
  Click on the editor to create a new state owned by player 0.
</dd>
<dt><img src="images/SquareState.png" alt="Square State" /></dt>
<dd>
  Click on the editor to create a new state owned by player 1.
</dd>
<dt><img src="images/Transition.png" alt="Transition" /></dt>
<dd>
  See also the <a href="#editors:automaton:toolbar_items">toolbar items</a>
  for finite state automata.
</dd>
<dt><img src="images/Delete.png" alt="Delete" /></dt>
<dd>
  See also the <a href="#editors:automaton:toolbar_items">toolbar items</a>
  for finite state automata.
</dd>
<dt><img src="images/WinningCondition.png" alt="Winning Condition" /></dt>
<dd>
  Open the winning condition editor.
  See also <a href="#editors:automaton:toolbar:acc">
  <img src="images/Acc.png" border="0" alt="Acceptance Condition" /></a>
  for finite state automata.
</dd>
<dt><img src="images/Focus.png" alt="Focus" /></dt>
<dd>
  See also the <a href="#editors:automaton:toolbar_items">toolbar items</a>
  for finite state automata.
</dd>
<dt><img src="images/Color.png" alt="Color" /></dt>
<dd>
  See also the <a href="#editors:automaton:toolbar_items">toolbar items</a>
  for finite state automata.
</dd>
</dl>

<!-- ================== Menu Items ================== -->

<h1><a name="menu">Menu Items</a></h1>

The menu items listed in the following come from the default installation.

<p class="plain">
Quick links: 
<a href="#menu:file">File</a>,
<a href="#menu:edit">Edit</a>,
<a href="#menu:view">View</a>,
<a href="#menu:repository">Repository</a>,
<a href="#menu:formula">Formula</a>,
<a href="#menu:automaton">Automaton</a>,
<a href="#menu:game">Game</a>,
<a href="#menu:window">Window</a>,
<a href="#menu:help">Help</a>
</p>

<h2><a name="menu:file">File</a></h2>

<ul>
  <li><b>New</b> - Create a new editable object.</li>
  <li>
    <b>Open File...</b> - Open a file.
    The supported file formats are listed in the following.
    <ul>
      <li>GFF (GOAL File Format) - The XML file format used by GOAL.</li>
      <li>Antichain Format - The file format used by
      <a href="http://www.lsv.ens-cachan.fr/~doyen/antichains/antichains.html">mh</a>
      for checking universality of NBW.</li>
      <li>BA Format - A file format used in Ramsey-based containment testing. See
      <a href="http://www.languageinclusion.org/CAV2010/#BA">here</a> for more details.</li>
      <li>JFLAP File Format (JFF) - The file format used by
      <a href="http://www.jflap.org/">JFLAP</a>. Currently, only finite state automata
      in JFF are supported.</li>
      <li>LTL2Buchi Format - The XML file format output by
      <a href="http://ti.arc.nasa.gov/profile/dimitra/projects-tools/#LTL2Buchi">LTL2Buchi</a>
      with the argument <code>-o xml</code>.</li>
      <li>MoDeLLa Format - The XML file format output by MoDeLLa with the argument
      <code>-n</code>.</li>
      <li>PGSolver Format - The file format used by
      <a href="http://www2.tcs.ifi.lmu.de/pgsolver/">PGSolver</a> to define parity
      games.</li>
      <li>Promela Never Claim - The file format used by <a href="http://spinroot.com/">SPIN</a>
      to define B&uuml;chi automata. The Promela never claim can be output
      by <a href="http://spinroot.com/">SPIN</a>,
      by <a href="http://ti.arc.nasa.gov/profile/dimitra/projects-tools/#LTL2Buchi">LTL2Buchi</a> with
      the <code>-o promela</code> argument,
      by MoDeLLa with the <code>-s</code> argument, or by other tools.
      </li>
    </ul>
  </li>
  <li><b>Close</b> - Close the active tab.</li>
  <li><b>Close All</b> - Close all tab.</li>
  <li><b>Save</b> - Save the active object to a file.</li>
  <li>
    <b>Save As...</b> - Save the active object to a specified file in a
    specified format that can be decoded back.
    The supported file formats are listed in the following.
    <ul>
      <li>GOAL File Format (GFF)</li>
      <li>Antichain Format - This output format is available only for
      B&uuml;chi automata with alphabets of size 2.</li>
      <li>BA Format - This output format is available only for B&uuml;chi
      automata with classical alphabets.</li>
      <li>JFLAP File Format (JFF) - This output format is available only for classic
      finite state automata.</li>
      <li>PGSolver - This output format is available only for parity games.
      Note that the output will discard all transition labels.</li>
      <li>Promela Never Claim - This output format is available only for
      B&uuml;chi automata.</li>
    </ul>
  </li>
  <li><b>Save All</b> - Save all objects.</li>
  <li><b>Import</b> - Import objects from other formats.</li>
  <li>
    <b>Export</b>
    <ul>
      <li><b>Single</b> - Export an object to a file in a format that may
      not be decoded back to the object.
      The supported file formats are listed in the following.
      <ul>
        <li>GOAL File Format (GFF)</li>
        <li>Antichain Format - This output format is available only for
        B&uuml;chi automata with alphabets of size 2.</li>
        <li>BA Format - This output format is available only for B&uuml;chi
        automata with classical alphabets.</li>
        <li>DOT Format - A file format used by <a href="http://www.graphviz.org/">Graphviz</a>.
        This output format is available only for B&uuml;chi automata.</li>
        <li>GasTeX - <a href="http://www.lsv.ens-cachan.fr/~gastin/gastex/">GasTeX</a> is a
        LaTeX package for drawing graphs and automata.</li>
        <li>JFLAP File Format (JFF) - This output format is available only for classic
        finite state automata.</li>
        <li>JGraph XML - <a href="http://www.jgraph.com/">JGraph</a> is a general drawing
        library. This output format is available only for finite state automata.</li>
        <li>JPEG</li>
        <li>PGSolver - This output format is available only for parity games.</li>
        <li>Portable Network Graphics (PNG)</li>
        <li>Promela Never Claim - This output format is available only for B&uuml;chi
        automata.</li>
        <li>Scalable Vector Graphics (SVG)</li>
        <li>TikZ - <a href="http://pgf.sourceforge.net/">TikZ/PGF</a> is a LaTeX package
        for generating graphics.</li>
        <li>Vaucanson-G - <a href="http://vaucanson-project.org/en/VauCanSon-G/">Vaucanson-G</a>
        is a LaTeX package for drawing automata.</li>
      </ul>
      </li>
      <li><b>Multiple</b> - Export multiple objects to a single file.
      The file is always in GOAL File Format (GFF).
      </li>
    </ul>
  </li>
  <li><b>Print</b> - Print the active object.</li>
  <li>
    <b>Recent Files</b> - Open a recent file, open all recent files, or clear
    the recent file history.
    <div class="tip">
      Use Ctrl-Shift-R or CMD-Shift-R (in Mac OS) and number keys to quickly open recent files.
    </div>
  </li>
  <li><b>Exit</b> - Quit GOAL.</li>
</ul>

<h2><a name="menu:edit">Edit</a></h2>

<ul>
  <li><b>Undo</b> - Undo an action.</li>
  <li><b>Redo</b> - Redo an action.</li>
  <li><b>Select All</b> - Select all states and transitions in the active
  automaton.</li>
  <li><b>Search</b> - Search states in the active automaton.</li>
  <li><b>Cut</b> - Cut text in a formula editor or copy states in an automaton
  editor.</li>
  <li><b>Copy</b> - Copy text in a formula editor or copy states in an automaton
  editor to the clipboard.</li>
  <li><b>Paste</b> - Paste text to a formula editor or paste states to an
  automaton editor.</li>
  <li>
    <b>Delete</b> - Delete selected automaton components or selected text.
  </li>
  <li>
    <b>Merge</b> - Merge selected states.
  </li>
  <li>
    <b>Copy As</b> - Copy selected states in an automaton editor to the
    clipboard in various plain text formats.
    If no state is selected, the whole automaton will be copied.
    <ul>
      <li><b>Promela</b></li>
      <li><b>LaTeX (GasTeX)</b></li>
      <li><b>LaTeX (Tikz)</b></li>
      <li><b>LaTeX (Vaucanson-G)</b></li>
    </ul>
  </li>
  <li><b>Preferences</b> - Set the user preferences.</li>
</ul>

<h2><a name="menu:view">View</a></h2>

<ul>
  <li><b>Property Editor</b> - Toggle the display of the property editor.</li>
  <li>
    <b>Recent Files</b> - Open a dialog for selecting recent files by number
    keys 0-9.
  </li>
  <li><b>Snap To Grid</b> - Snap the center of a state to a grid.</li>
  <li>
    <b>Display Gridlines</b> - Display gridlines.
  </li>
  <li>
    <b>Display Guidelines</b> - Display some guidelines when dragging a state.
  </li>
  <li>
    <b>Floatable Toolbar</b> - Make the toolbars floatable.
  </li>
  <li>
    <b>Zoom</b> - Set the zoom level of an automaton.
    <div class="tip">
      Use Ctrl-MouseWheel or Mac trackpad (pinch open &amp; close) to zoom in or
      out quickly. 
    </div>
  </li>
  <!-- <li><b>Debug</b> - Turn on some debugging information.</li> -->
</ul>

<h2><a name="menu:repository">Repository</a></h2>

<ul>
  <li><b>Local B&uuml;chi Repository</b> - Display the local repository
  containing the system-defined and the user-defined automata.</li>
  <li><b>Online B&uuml;chi Repository</b> - Display the automata on the
  <a href="http://buchi.im.ntu.edu.tw/">B&uuml;chi Store</a>
  [<a href="#references:ttcc11">TTCC11</a>, <a href="#references:ttcc13">TTCC13</a>].</li>
  <li><b>B&uuml;chi Store Uploader</b> - Upload the active automaton
  to the <a href="http://buchi.im.ntu.edu.tw/">B&uuml;chi Store</a>
  [<a href="#references:ttcc11">TTCC11</a>, <a href="#references:ttcc13">TTCC13</a>].</li>
</ul>

<h2><a name="menu:formula">Formula</a></h2>

<ul>
  <li><b>Satisfiability</b> - Test if a formula is satisfiable.</li>
  <li><b>Validity</b> - Test if a formula is valid</li>
  <li><b><a name="menu:temporal_hierarchy">Temporal Hierarchy</a></b> -
  Classify a QPTL formula into the Temporal Hierarchy
  [<a href="#references:mp90">MP90</a>].
  <ul>
    <li><b>Syntax-Based</b>: Classify a QPTL formula into standard &kappa;-formulae
    where &kappa; is the classes of the Temporal Hierarchy
    [<a href="#references:cmp92">CMP92</a>].
    A standard &kappa;-formula specifies a &kappa;-property.
    A property specifiable by temporal logics is a &kappa;-property if and
    only if it is specifiable by a future standard &kappa;-formula. 
    </li>
    <li><b>Language-Based</b>: Classify the language of a QPTL formula into the
    Temporal Hierarchy.</li>
  </ul>
  <br/>
  <div class="figure">
    <a href="images/TemporalHierarchy.png">
      <img border="0" src="images/TemporalHierarchy_s.png" alt="Temporal Hierarchy" />
    </a>
    <div class="caption">
      The Temporal Hierarchy where <code>p</code>, <code>q</code>,
      <code>p<sub>i</sub></code>, and <code>q<sub>i</sub></code> are
      past formulae.
    </div>
  </div>
  </li>
  <li>
    <b>Negation Normal Form</b> - Convert a logic formula into negation
    normal form if it is possible.
  </li>
  <li>
    <b>Prenex Normal Form</b> - Convert a logic formula into prenex
    normal form if it is possible.
  </li>
  <li>
    <b>Simplify</b> - Simplify a logic formula or an algebraic expression
    syntactically.
  </li>
  <li>
    <b>Past/Future Separation</b> - Separate the past operators and the
    future operators in a QPTL formula [<a href="#references:gab87">Gab87</a>].
    The QPTL formula is required to be convertible to prenex normal
    form.
  </li>
  <li>
    <b>Translate RE To NFW</b> - Translate a regular expression to an
    equivalent NFW.
  </li>
  <li>
    <b>Translate ORE To NFW</b> - Translate an &omega;-regular expression
    to an equivalent NBW.
  </li>
  <li>
    <b>Translate QPTL</b> - Translate a QPTL formula to an equivalent
    automaton.
    <ul>
      <li>
        <b>To NGBW (Label-On-State)</b> - Translate a QPTL formula to a
        label-on-state NGBW.
        <ul>
          <li><b>Tableau (MP)</b> - An implementation of the translation
          algorithm in [<a href="#references:mp95">MP95</a>].</li>
          <li><b>Incremental Tableau (KMMP)</b> - An implementation of the
          translation algorithm in [<a href="#references:kmmp93">KMMP93</a>].
          </li>
          <li><b>Temporal Tester (KP)</b> - An implementation of the
          translation algorithm in [<a href="#references:kp00">KP00</a>].</li>
          <li><b>Extended On-The-Fly (GPVW)</b> - An extended version of the
          original on-the-fly translation algorithm GPVW [<a
          href="#references:gpvw95">GPVW95</a>]. The extension allows the
          translation of quantified formulae and past formulae.</li>
          <li><b>Extended On-The-Fly (GPVW+)</b> - An extended version of the
          on-the-fly algorithm GPVW+ [<a href="#references:gpvw95">GPVW95</a>].
          The extension allows the translation of quantified formulae.</li>
          <li><b>Extended LTL2AUT (DGV)</b> - An extended version of the
          LTL2AUT translation algorithm [<a href="#references:dgv99">DGV99</a>].
          The extension allows the translation of quantified formulae and
          past formulae.</li>
          <li><b>Extended LTL2AUT+ (DGV)</b> - A slightly improved version
          of the extended LTL2AUT translation algorithm.</li>
          <li><b>Extended MoDeLLa (ST)</b> - An implementation of the
          MoDeLLa translation algorithm [<a href="#references:st03">ST03</a>]
          with extensions for past operators.</li>
          <li><b>Step-By-Step Tableau (MP)</b></li>
          <li><b>Step-By-Step Extended On-The-Fly (GPVW)</b></li>
          <li><b>Step-By-Step Extended On-The-Fly (GPVW+)</b></li>
          <li><b>Step-By-Step Extended LTL2AUT (DGV)</b></li>
          <li><b>Step-By-Step Extended LTL2AUT+ (DGV)</b></li>
          <li><b>Step-By-Step Extended MoDeLLa (ST)</b></li>
        </ul>
      </li>
      <li>
        <b>To NBW (Label-On-State)</b> - Translate a QPTL formula to a
        label-on-state NBW.
        <ul>
          <li><b>Tableau (MP)</b></li>
          <li><b>Incremental Tableau (KMMP)</b></li>
          <li><b>Temporal Tester (KP)</b></li>
          <li><b>Extended On-The-Fly (GPVW)</b></li>
          <li><b>Extended On-The-Fly (GPVW+)</b></li>
          <li><b>Extended LTL2AUT (DGV)</b></li>
          <li><b>Extended LTL2AUT+ (DGV)</b></li>
          <li><b>Extended MoDeLLa (ST)</b></li>
        </ul>
      </li>
      <li>
        <b>To NGBW</b> - Translate a QPTL formula to an NGBW.
        <ul>
          <li><b>Tableau (MP)</b></li>
          <li><b>Incremental Tableau (KMMP)</b></li>
          <li><b>Temporal Tester (KP)</b></li>
          <li><b>Extended On-The-Fly (GPVW)</b></li>
          <li><b>Extended On-The-Fly (GPVW+)</b></li>
          <li><b>Extended LTL2AUT (DGV)</b></li>
          <li><b>Extended LTL2AUT+ (DGV)</b></li>
          <li><b>Extended MoDeLLa (ST)</b></li>
        </ul>
      </li>
      <li>
        <b>To NBW</b> - Translate a QPTL formula to an NBW.
        <ul>
          <li><b>Tableau (MP)</b></li>
          <li><b>Incremental Tableau (KMMP)</b></li>
          <li><b>Temporal Tester (KP)</b></li>
          <li><b>Extended On-The-Fly (GPVW)</b></li>
          <li><b>Extended On-The-Fly (GPVW+)</b></li>
          <li><b>Extended LTL2AUT (DGV)</b></li>
          <li><b>Extended LTL2AUT+ (DGV)</b></li>
          <li><b>KP02</b> - An implementation of the inductive translation
          algorithm in [<a href="#references:kp02">KP02</a>].
          The QPTL formula is not required to be in prenex normal form.</li>
          <li><b>Extended MoDeLLa (ST)</b></li>
          <li><b>LTL2BA (GO)</b> - An implementation of the translation
          algorithm in [<a href="#references:go01">GO01</a>].
          In this implementation, the simplification of LTL formulae applied
          in the paper is not fully implemented.
          The definitions of transition relations are also different in this
          implementation.
          </li>
          <li><b>PLTL2BA (GO)</b> - An implementation of the translation
          algorithm in [<a href="#references:go03">GO03</a>].</li>
          <li><b>Extended Couvreur's Algorithm</b> - An implementation of the
          Couvreur's translation algorithm [<a href="#references:cou99">Cou99</a>]
          with extensions for past operators.
          </li>
          <li><b>Extended LTL2BUCHI (GL)</b> - An implementation of the LTL2BUCHI
          translation algorithm [<a href="#references:gl02">GL02</a>] with
          extensions for past operators.</li>
          <li><b>CCJ09</b> - An implementation of the translation algorithm in
          [<a href="#references:ccj09">CCJ09</a>]. The supported formula patterns
          include:
            <ul>
              <li>&lt;&gt;(p1 &and; ()(p<sub>1</sub> &and; ()(... &and; ()p<sub>1</sub>))) &and; &lt;&gt;(p<sub>2</sub> &and; ()(p<sub>2</sub> &and; ()(... &and; ()p<sub>2</sub>))) &and; ...</li>
              <li>&lt;&gt;(p<sub>1</sub> &and; &lt;&gt;(p<sub>2</sub> &and; &lt;&gt;(... &and; &lt;&gt;p<sub>n</sub>))) &and; &lt;&gt;(q<sub>1</sub> &and; &lt;&gt;(q<sub>2</sub> &and; &lt;&gt;(... &and; &lt;&gt;q<sub>m</sub>))) &and; ...</li>
              <li>[]&lt;&gt;p<sub>1</sub> &and; []&lt;&gt;p<sub>2</sub> &and; ... &and; []&lt;&gt;p<sub>n</sub></li>
              <li>&lt;&gt;[]p<sub>1</sub> &or; &lt;&gt;[]p<sub>2</sub> &or; ... &or; &lt;&gt;[]p<sub>n</sub></li>
            </ul>
          </li>
          <li><b>QPTL2BA</b> - A translation developed by the GOAL development
          team from a QPTL formula in canonical forms to an equivalent
          B&uuml;chi automaton.
          Past sub-formulae are required to be in prenex normal form.
          Formulae that have boolean operators, future operators, and
          quantifications applied outside sub-formulae in canonical forms are
          also supported.
          See the <a href="#menu:temporal_hierarchy">Temporal Hierarchy</a> for
          more details of canonical forms.</li>
        </ul>
        <div class="figure">
          <table align="center" class="decorated" border="2" cellpadding="5" cellspacing="0">
            <tr class="header"> <th>Algorithm</th> <th>Supported Formulae</th> </tr>
            <tr class="row1"> <td>Tableau (MP)</td> <td>QPTL in prenex normal form</td> </tr>
            <tr class="row2"> <td>Incremental Tableau (KMMP)</td> <td>QPTL in prenex normal form</td> </tr>
            <tr class="row1"> <td>Temporal Tester (KP)</td> <td>QPTL in prenex normal form</td> </tr>
            <tr class="row2"> <td>Extended On-The-Fly (GPVW)</td> <td>QPTL in prenex normal form</td> </tr>
            <tr class="row1"> <td>Extended On-The-Fly (GPVW+)</td> <td>Future QPTL in prenex normal form</td> </tr>
            <tr class="row2"> <td>Extended LTL2AUT (DGV)</td> <td>QPTL in prenex normal form</td> </tr>
            <tr class="row1"> <td>Extended LTL2AUT+ (DGV)</td> <td>QPTL in prenex normal form</td> </tr>
            <tr class="row2"> <td>KP02</td> <td>QPTL</td> </tr>
            <tr class="row1"> <td>Extended MoDeLLa (ST)</td> <td>QPTL in prenex normal form</td> </tr>
            <tr class="row2"> <td>LTL2BA (GO)</td> <td>Future QPTL in prenex normal form</td> </tr>
            <tr class="row1"> <td>PLTL2BA (GO)</td> <td>QPTL in prenex normal form</td> </tr>
            <tr class="row2"> <td>Extended Couvreur's Algorithm</td> <td>QPTL in prenex normal form</td> </tr>
            <tr class="row1"> <td>Extended LTL2BUCHI (GL)</td> <td>QPTL in prenex normal form</td> </tr>
            <tr class="row2"> <td>QPTL2BA</td> <td>QPTL formulae constructed from canonical forms</td> </tr>
          </table>
          <div class="caption">A table of formulae supported by the above translation algorithms.</div>
        </div>
      </li>
      <li>
        <b>To NTGBW</b> - Translate a QPTL formula to an NTGBW.
        <ul>
          <li><b>LTL2BA (GO)</b></li>
          <li><b>PLTL2BA (GO)</b></li>
          <li><b>Extended Couvreur's Algorithm</b></li>
          <li><b>Extended LTL2BUCHI (GL)</b></li>
        </ul>
      </li>
      <li>
        <b>To NABW</b> - Translate a QPTL formula to an NABW.
        <ul>
          <li><b>QPTL2BA</b> - A translation developed by the GOAL development
          team from a QPTL formula without past operators to an equivalent
          alternating B&uuml;chi automaton.</li>
        </ul>
      </li>      
      <li>
        <b>To NACW</b> - Translate a QPTL formula to an NACW.
        <ul>
          <li><b>LTL2VWAA (GO)</b> - The translation from an LTL formula
          to an equivalent <a href="#terminology:vwaa">VWAA</a> used by
          LTL2BA.</li>
        </ul>
      </li>
      <li>
        <b>To NTWACW</b> - Translate a QPTL formula to a two-way NACW.
        <ul>
          <li><b>PLTL2TWVWAA (GO)</b> - The translation from an LTL formula
          to an equivalent two-way <a href="#terminology:vwaa">VWAA</a> used by
          PLTL2BA.</li>
          <li><b>QPTL2BA</b> - A translation developed by the GOAL development
          team from a QPTL formula in canonical forms to an equivalent two-way
          alternating co-B&uuml;chi automaton.
          Past sub-formulae are required to be in prenex normal form.
          See the <a href="#menu:temporal_hierarchy">Temporal Hierarchy</a> for
          more details of canonical forms.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <b>Translate ACTL</b> - Translate an ACTL formula <code>f</code> to a
    Kripke structure <code>A</code> interpreted as a label-on-state automaton
    such that for all Kripke structure <code>B</code>, <code>B |= f</code> iff
    <code>B &le; A</code>.  For more details about <code>|=</code> and
    <code>&le;</code>, please refer to [<a href="#references:gl94">GL94</a>].
    <ul>
      <li>
        <b>To NGBW (label-on-state)</b>
        <ul>
          <li><b>PMT02</b> - An implementation of a variant tableau
          construction based on [<a href="#references:pmt02">PMT02</a>].</li>
        </ul>
      </li>
    </ul> 
  </li>
</ul>

<h2><a name="menu:automaton">Automaton</a></h2>

<ul>
  <li>
    <b>Alphabet</b> - Operations on the alphabet of the active automaton.
    <ul>
      <li><b>Display Propositions/Symbols</b> - Display the propositions or
      the classical symbols in the alphabet of the active automaton.</li>
      <li><b>Expand Alphabet</b> - Expand the alphabet of the active automaton
      by a proposition or a classical symbol.</li>
      <li><b>Contract Alphabet (Projection)</b> - Project out a proposition
      or a classical symbol from the alphabet of the active automaton.</li>
      <li><b>Rename Proposition/Symbol</b> - Rename a proposition or a
      classical symbol to another literal.</li>
      <li><b>Alphabet Abstraction</b> - abstract the alphabet of an automaton that
      has
        <ul>
          <li>a propositional alphabet,</li>
          <li>labels on transitions, and</li>
          <li>an acceptance condition on states.</li>
        </ul>
      The original propositions of the automaton will be replaced by new
      propositions defined as predicates of the original propositions.
      For example, consider the following automaton with an alphabet formed
      by the atomic propositions {p, q},
      <div class="figure">
        <a href="images/AlphabetAbstraction1.png">
          <img src="images/AlphabetAbstraction1.png" border="0" alt="An automaton before the alphabet abstraction" />
        </a>
        <div class="caption">An automaton before the alphabet abstraction</div>
      </div>
      If the only new proposition r is defined as p &and; q.
      Then, the alphabet of the automaton after the abstraction will become
      {"r", "&not; r"} and the automaton after the abstraction is shown as the
      following. 
      <div class="figure">
        <a href="images/AlphabetAbstraction2.png">
          <img src="images/AlphabetAbstraction2.png" border="0" alt="An automaton after the alphabet abstraction" />
        </a>
        <div class="caption">An automaton after the alphabet abstraction</div>
      </div>
      </li>
      <li><b>Convert Alphabet Type</b> - Convert between propositional alphabet
      and classical alphabet.</li>
    </ul>
  </li>
  <li><b>Duplicate</b> - Duplicate the active automaton.</li>
  <li><b>Merge</b> - Merge an automaton into the active automaton. The acceptance
  conditions are also merged.</li>
  <li>
    <b>Acceptance Condition</b> - Operations on the acceptance condition of
    the active automaton.
    <ul>
      <li><b>Reset Acceptance Condition</b> - Reset the acceptance condition of
      the active automaton.</li>
      <li><b>Maximize Acceptance Set</b> - Maximize the B&uuml;chi acceptance
      set of the active NBW without changing its language.</li>
      <li><b>Minimize Acceptance Set</b> - Simplify the B&uuml;chi acceptance
      set of the active NBW without changing its language.</li>
      <li>
        <b>Parity Interpretation</b> - Change a parity condition from an
        interpretation to another interpretation. The parity interpretation can
        be min-even, min-odd, max-even, or max-odd. Note that GOAL uses min-even.
      </li>
      <li>
        <b>Parity Compression</b> - Compress parity conditions.
      </li>
      <li>
        <b>Parity Propagation</b> - Propagate parities of states in a parity condition.
      </li>
    </ul>
  </li>
  <li>
    <b>Utilities</b>
    <ul>
      <li><b>Find MSCCs</b> - Display the maximal strongly connected components
      (MSCC) in the active automaton.</li>
      <li><b>Find Elementary Cycles</b> - Display the elementary cycles in the
      active automaton.
      This is an implementation of the algorithm in [<a href="#references:joh75">Joh75</a>].
      </li>
      <li><b>Compute Simulation Relations (Naive)</b> - Display the direct and
      the reverse simulation relations [<a href="#references:sb00">SB00</a>]
      baed on a naive computation procedure.</li>
      <li><b>Compute Simulation Relations (SchematicSimilarity1)</b> - Display
      the direct and the reverse simulation relations baed on the
      SchematicSimilarity1 procedure in
      [<a href="#references:hhk95">HHK95</a>].</li>
      <li><b>Compute Simulation Relations (RefinedSimilarity)</b> - Display
      the direct and the reverse simulation relations baed on the
      RefinedSimilarity procedure in
      [<a href="#references:hhk95">HHK95</a>].</li>
      <li><b>Compute Simulation Relations (EfficientSimilarity)</b> - Display
      the direct and the reverse simulation relations baed on the
      EfficientSimilarity procedure in
      [<a href="#references:hhk95">HHK95</a>].</li>
      <li><b>Compute Delayed Simulation Relation</b> - Display the delayed
      simulation relation of a B&uuml;chi automaton based on the procedure in
      [<a href="#references:ews01">EWS01</a>].
      Instead of small progress measure applied in the papers, we use the
      user-default parity game solver to solve delayed simulation games.</li>  
      <li><b>Compute Fair Simulation Relation</b> - Display the fair simulation
      relation of a B&uuml;chi automaton based on the procedure in
      [<a href="#references:ews01">EWS01</a>] for label-on-transition B&uuml;chi
      automata or the procedure in [<a href="#references:gbs02">GBS02</a>] for
      label-on-state B&uuml;chi automata.
      Instead of small progress measure applied in the papers, we use the
      user-default parity game solver to solve fair simulation games.  
      </li>
      <li>
        <b>&epsilon;-Transition Elimination</b> - Eliminate &epsilon;-transitions
        of a classic finite state automaton with a classical alphabet.
      </li>
      <li><b>&omega; Operation</b> - Creates an NBW that accepts
      <code>L<sup>&omega;</sup></code> where <code>L</code> is the language
      of the active NFW.</li>
    </ul>
  </li>
  <li>
    <b><a name="menu:automaton:layout">Layout</a></b> - Lay out the active
    automaton by various layout algorithms, including layout creation
    algorithms and layout adjustment algorithms.
    <ul>
      <li><b>Circle Layout</b> - Place states around a circle.</li>
      <li><b>FR Layout</b> - An implementation of the FR layout algorithm
      [<a href="#references:fr91">FR91</a>].</li>
      <li><b>Force-Scan Algorithm (FSA)</b> - An implementation of the
      force-scan algorithm [<a href="#references:el92">EL92</a>,
      <a href="#references:mels95">MELS95</a>,
      <a href="#references:le98">LE98</a>].</li>
      <li><b>Force-Transfer Algorithm (FTA)</b> - An implementation of the
      force-transfer algorithm [<a href="#references:hl03">HL03</a>,
      <a href="#references:hlsg07">HLSG07</a>].</li>
      <li><b>GEM Layout</b> - An implementation of the GEM layout algorithm
      [<a href="#references:flm94">FLM94</a>].</li>
      <li><b>ISOM Layout</b> - An implementation of the ISOM layout algorithm
      [<a href="#references:Mey98">Mey98</a>].</li>
      <li><b>Improved Push Force-Scan Algorithm</b> - An implementation of the
      improved push force-scan algorithm
      [<a href="#references:himf98">HIMF98</a>,
      <a href="#references:himf02">HIMF02</a>].</li>
      <li><b>KK Layout</b> - An implementation of the KK layout algorithm
      [<a href="#references:kk89">KK89</a>].</li>
      <li><b>Random Layout</b> - Place states in random locations.</li>
      <li><b>SA Layout</b> - An implementation of the SA layout algorithm
      [<a href="#references:dh96">DH96</a>].</li>
      <li><b>Tree Layout</b> - An implementation of a naive tree layout.</li>
    </ul>
    <div class="tip">
      Press Shift and do the layout to play layout animation.
    </div>
  </li>
  <li><b>Input Test</b> - Test if a word is accepted by the active automaton.
    <p class="plain">
      A finite word is a sequence of symbols
      <code>w<sub>0</sub> w<sub>1</sub> &hellip; w<sub>n</sub></code>
      where each symbol w<sub>i</sub> may be enclosed in parentheses.
      An infinite word <code>uv<sup>&omega;</sup></code> is denoted by
      <code>w<sub>0</sub> w<sub>1</sub> &hellip; w<sub>i</sub> { w<sub>i+1</sub> &hellip; w<sub>n</sub> }</code>
      where <code>u = w<sub>0</sub> w<sub>1</sub> &hellip; w<sub>i</sub></code> and
      <code>v = w<sub>i+1</sub> &hellip; w<sub>n</sub></code>.
      For example, assuming that p and q are the atomic propositions,
      <code>(p q)(p ~q)(~p ~q) { (p q)(~p q) }</code> is a valid infinite word.
      When spaces and parentheses are omitted in a word, GOAL will decompose
      the word string into valid symbols automatically (though the decomposition
      may be ambiguous).
      Thus, <code>pqp~q~p~q{pq~pq}</code> is exactly the same as
      <code>(p q)(p ~q)(~p ~q) { (p q)(~p q) }</code>.
    </p>

    <ul>
      <li><b>Direct Input Test</b> - Test if a word is accepted by the active
      automaton. The result will be displayed on the screen directly.</li>
      <li><b>Input Simulator</b> - Display an interactive input simulator to
      see if a word is accepted.
      
      <div class="figure">
        <a href="images/InputSimulator.png">
          <img src="images/InputSimulator_s.png" border="0" alt="Input Simulator" />
        </a>
        <div class="caption">
          Input simulator
        </div>
      </div>
      
      The left-hand side in the input simulator is a read-only editor
      containing an automaton, while the right-hand side is a list containing
      the runs of the automaton on a word computed so far.  A run in the list
      is displayed as a current state and the word with an "&uarr;" indicating
      the next symbol to be read (the symbol after "&uarr;").  A run is
      respectively colored by red or green if it is respectively rejecting or
      accepting.  A run is colored by gray if it is frozen.  A frozen run will
      not read any symbol until it is thawed.  There are several toolbar icons
      for controlling the input simulator as shown below.

      <dl>
        <dt><img src="images/NextStep.png" alt="Next Symbol" /></dt>
        <dd>
          Read the next symbol.
        </dd>
        <dt><img src="images/NextStage.png" alt="Next 10 Symbols" /></dt>
        <dd>
          Read the next 10 symbols.
        </dd>
        <dt><img src="images/PrevStep.png" alt="" /></dt>
        <dd>
          Go one step backward.  Note that deleted and dead runs will not be
          recovered.
        </dd>
        <dt><img src="images/PrevStage.png" alt="Reset All" /></dt>
        <dd>
          Reset all.
        </dd>
        <dt><img src="images/Snowflake.png" alt="Freeze/Thaw" /></dt>
        <dd>
          Freeze or thaw a run.
        </dd>
        <dt><img src="images/Delete.png" alt="Delete" /></dt>
        <dd>
          Delete a run.
        </dd>
        <dt><img src="images/Information.png" alt="Details of a run" /></dt>
        <dd>
          Show the details of a run.
        </dd>
      </dl>
      </li>
      <li><b>Run Tree</b> - Interactively display the run tree of the active
      automaton on a word.</li>
      <li><b>Run DAG</b> - Interactively display the run DAG of the active
      automaton on a word.</li>
      <li><b>Split Tree</b> - Interactively display the split tree of the
      active automaton on a word.</li>
      <li><b>Reduced Split Tree</b> - Interactively display the reduced split
      tree of the active automaton on a word.</li>
    </ul>
  </li>
  <li><b>Emptiness</b> - Test if the language of the active automaton is
  empty.</li>
  <li>
    <b>Containment</b> - Test if the language of the active automaton is
    contained in the language of another automaton by checking if the
    intersection of the active automaton and the complement of the other
    automaton is empty or not. If the intersection is empty, the active
    automaton is contained in the other automaton.
    <ul>
      <li><b>With Naive Approach</b> -
      Explicitly construct the intersection of the first automaton and the
      complement of the second automaton. The complement is constructed
      explicitly by the default complementation construction. If the
      intersection is empty, then the first automaton is contained in the
      second automaton.</li>
      <li><b>On-The-Fly With Safra's Construction</b> - On-the-fly
      construct the intersection of the first automaton and the complement
      of the second automaton. The complement is constructed on-the-fly
      by the Safra's construction [<a href="#references:saf88">Saf88</a>].
      </li>
      <li><b>On-The-Fly With Modified Safra's Construction</b> - On-the-fly
      construct the intersection of the first automaton and the complement
      of the second automaton. The complement is constructed on-the-fly
      by the modified Safra's construction. See <a
      href="#menu:automaton:complement:modifiedsafra">here</a> for more
      information.</li>
      <li><b>On-The-Fly With Muller-Schupp Construction</b> - On-the-fly
      construct the intersection of the first automaton and the complement
      of the second automaton. The complement is constructed on-the-fly
      by the Muller-Schupp construction
      [<a href="#references:ms95">MS95</a>,
      <a href="#references:atw06">ATW06</a>].</li>
      <li><b>On-The-Fly With Safra-Piterman Construction</b> - On-the-fly
      construct the intersection of the first automaton and the complement
      of the second automaton. The complement is constructed on-the-fly
      by the Safra-Piterman construction
      [<a href="#references:pit06">Pit06</a>].</li>
      <li><b>On-The-Fly With Slice-Based Construction</b> - On-the-fly
      construct the intersection of the first automaton and the complement
      of the second automaton. The complement is constructed on-the-fly
      by the slice-based construction [<a href="#references:kw08">KW08</a>,
      <a href="#references:vw07">VW07</a>]. </li>
<!--
      <li><b>Slice-Based Antichain</b> - Compute the forward fixpoint described
      in [<a href="#references:wdmr08">WDMR08</a>]. If the containment does
      not hold, no counterexample will be given.</li>
-->
    </ul>
  </li>
  <li><b>Equivalence</b> - Test if two automata are equivalent, that is, they
  have the same language.</li>
  <li><b>Simulated</b>
    <ul>
      <li><b>Direct Simulated By</b> - Test if an automaton is direct simulated
      by another automaton.</li>
      <li><b>Delayed Simulated By</b> - Test if a B&uuml;chi automaton is delayed
      simulated by another B&uuml;chi automaton
      [<a href="#references:ews01">EWS01</a>].</li>
      <li><b>Fairly Simulated By</b> - Test if a B&uuml;chi automaton is fairly
      simulated by another B&uuml;chi automaton
      [<a href="#references:ews01">EWS01</a>,
      <a href="#references:gbs02">GBS02</a>].</li>
    </ul>
  </li>
  <li><b>Simulation Equivalence</b> - Test if two automata are simulation
  equivalent, that is, the initial state of an automaton can simulate the
  initial state of the other automaton, and vice versa.</li>
  <li>
    <b>Deterministic</b> 
    <ul>
      <li><b>Syntactically Deterministic</b> - Test if an automaton is
      syntactically deterministic.</li>
      <li><b>Semantically Deterministic</b> - Test if an automaton is
      semantically deterministic, that is, it is equivalent to a DBW.</li>
    </ul>
  </li>
  <li>
    <b>Aperiodic (Star-Free)</b> - Test the aperiodicity of an automaton or the
    language of an automaton based on [<a href="#references:dg08">DG08</a>].
    Currently, only classic finite automata and B&uuml;chi automata are
    supported.<br/>
    <br/>
    Let L be a regular language. Then the followings are equivalent.
    <ol>
      <li>L is first-order definable.</li>
      <li>L is star-free.</li>
      <li>L is aperiodic.</li>
      <li>The syntactic monoid of L (the transition monoid of the minimal
      deterministic automaton that recognizes L) is aperiodic.</li>
    </ol>
    <br/>
    Let L be an &omega;-regular language. Then the followings are equivalent.
    <ol>
      <li>L is first-order definable.</li>
      <li>L is star-free.</li>
      <li>L is aperiodic.</li>
      <li>L is definable in LTL.</li>
      <li>There is a counter-free B&uuml;chi automaton A with L = L(A).</li>
      <li>There is an aperiodic B&uuml;chi automaton A with L = L(A).</li>
    </ol>
    Let A be an B&uuml;chi automaton.
    <ol>
      <li>If A is counter-free, then A is aperiodic.</li>
      <li>If A is deterministic and aperiodic, then A is counter-free.</li>
    </ol>
  </li>
  <li>
    <b>Morphism</b>
    <ul>
      <li><b>Homomorphism</b> - Test if an automaton is homomorphic to another
      automaton.</li>
      <li><b>Isomorphism</b> - Test if two automata are isomorphic.</li>
    </ul>
  </li>
  <li><b>Temporal Hierarchy</b> - Classify an automaton into the Temporal
  Hierarchy [<a href="#references:mp90">MP90</a>].</li>
  <li><b>Closure</b> - Take the safety closure of the active automaton.</li>
  <li><b>Convert</b> - Convert the active automaton to another automaton type,
  logic formula, or algebraic expression.
    <ul>
      <li><b>Label Position</b> - Convert an automaton with labels on states
      to an automaton with labels on transitions and vice versa.</li>
      <li><b>Alternation Style</b> - Convert a DNF alternating automaton to
      a CNF alternating automaton and vice versa.</li>
      <li><b>To Regular Expression</b> - Convert a classic finite state automaton
      with a classical alphabet to an equivalent regular expression.</li>
      <li><b>To &omega;-Regular Expression</b> - Convert an &omega;-automaton
      with a classical alphabet to an equivalent &omega;-regular expression.</li>
      <li><b>To Game</b> - Convert a deterministic &omega;-automaton to a turn-based
      game.  The automaton is required to have a propositional alphabet, an acceptance
      condition on states, and labels on transitions.  The propositions are treated as
      Boolean variables and partitioned into two sets, of which one set is controlled
      by a player and the other set is controlled by its opponent.  In the context of
      synthesis, Player P0 acts as a module and Player P1 acts as the environment of
      the module.</li>
      <li><b>To NBW</b> - Convert an automaton to an equivalent B&uuml;chi automaton.</li>
      <li><b>To NCW</b> - Convert an automaton to an equivalent co-B&uuml;chi automaton.</li>
      <li><b>To NGBW</b> - Convert an automaton to an equivalent generalized B&uuml;chi automaton.</li>
      <li><b>To NMW</b> - Convert an automaton to an equivalent Muller automaton.</li>
      <li><b>To NRW</b> - Convert an automaton to an equivalent Rabin automaton.</li>
      <li><b>To NSW</b> - Convert an automaton to an equivalent Streett automaton.</li>
      <li><b>To NPW</b> - Convert an automaton to an equivalent parity automaton.</li>
      <li><b>To NTBW</b> - Convert an automaton to an equivalent transition B&uuml;chi automaton.</li>
      <li><b>To NTGBW</b> - Convert an automaton to an equivalent transition generalized B&uuml;chi automaton.</li>
      <li><b>To...</b> - Apply a custom conversion where several direct conversions
      may be chained.</li>
    </ul>
  </li>
  <li>
    <b>Determinize</b> - Determinize the active automaton to an equivalent
    deterministic automaton.
    <ul>
      <li><b>To DFW</b> - Determinize an NFW to an equivalent DFW.</li>
      <li><b>To DBW (Boker-Kupferman)</b> - Determinize an automaton to an
      equivalent DBW through DCW by the approach in
      [<a href="#references:bk09">BK09</a>] if the determinization is possible.
      </li>
      <li><b>To DBW (Landweber)</b> - Determinize an automaton to an equivalent
      DBW through DMW by the approach in [<a href="#references:lan69">Lan69</a>]
      if the determinization is possible.</li>
      <li><b>To DRW (Safra)</b> - Determinize an NBW to an equivalent DRW by
      Safra's construction [<a href="#references:saf88">Saf88</a>].
      Schewe's history trees [<a href="#references:sch09b">Sch09b</a>] are also
      implemented as an option.</li>
      <li><b>To DRW (Modified Safra)</b> - Determinize an NBW to an equivalent
      DRW by modified Safra's construction. See <a
      href="#menu:automaton:complement:modifiedsafra">here</a> for more
      information.</li>
      <li><b>To DRW (Muller-Schupp)</b> - Determinize an NBW to an equivalent
      DRW by Muller-Schupp construction [<a href="#references:ms95">MS95</a>,
      <a href="#references:atw06">ATW06</a>].</li>
      <li><b>To DPW (Safra-Piterman)</b> - Determinize an NBW to an equivalent
      DPW by Safra-Piterman construction [<a href="#references:pit06">Pit06</a>].
      Schewe's history trees [<a href="#references:sch09b">Sch09b</a>] are also
      implemented as an option.</li>
    </ul>    
  </li>
  <li>
    <b>Minimization</b> - Minimize a classic finite word automaton.
    <ul>
      <li>
        <b>By Classical Approach</b> - Minimize a classic finite word
        automaton by a classical approach.
      </li>
      <li>
        <b>By Hopcroft's Algorithm</b> - Minimize a classic finite word
        automaton by the Hopcroft's algorithm
        [<a href="#references:hop71">Hop71</a>].
      </li>
    </ul>
  </li>
  <li id="menu:automaton:product"><b>Product</b> -
  Take the synchronous or asynchronous product of two finite state automata.
  The two automata must have the same type of alphabet and have labels
  on transitions.
  The automaton structure of the product will be the same as that of the
  first automaton (the active one).
  The acceptance condition of the product only depends on the second
  automaton (the selected one in the options dialog).
  Let A<sub>1</sub>=(&Sigma;, Q<sub>1</sub>, q<sub>10</sub>, &delta;<sub>1</sub>,
  F<sub>1</sub>) and A<sub>2</sub>=(&Sigma;, Q<sub>2</sub>, q<sub>20</sub>,
  &delta;<sub>2</sub>, F<sub>2</sub>) be two &omega;-automata.
  The synchronous product of A<sub>1</sub> and A<sub>2</sub> is P = (&Sigma;, Q,
  q<sub>0</sub>, &delta;, F) where
    <ul>
      <li>Q = Q<sub>1</sub> &times; Q<sub>2</sub>,</li>
      <li>q<sub>0</sub> = (q<sub>10</sub>, q<sub>20</sub>),</li>
      <li>for all a &isin; &Sigma;, s<sub>1</sub>, t<sub>1</sub> &isin; Q<sub>1</sub>,
      and s<sub>2</sub>, t<sub>2</sub> &isin; Q<sub>2</sub>, ((s<sub>1</sub>,
      s<sub>2</sub>), a, (t<sub>1</sub>, t<sub>2</sub>)) &isin; &delta; iff
      (s<sub>1</sub>, a, t<sub>1</sub>) &isin; &delta;<sub>1</sub> and
      (s<sub>2</sub>, a, t<sub>2</sub>) &isin; &delta;<sub>2</sub>.</li>
    </ul> 
  The asynchronous product of A<sub>1</sub> and A<sub>2</sub> is P = (&Sigma;, Q,
  q<sub>0</sub>, &delta;, F) where
    <ul>
      <li>Q = Q<sub>1</sub> &times; Q<sub>2</sub>,</li>
      <li>q<sub>0</sub> = (q<sub>10</sub>, q<sub>20</sub>),</li>
      <li>for all a &isin; &Sigma;, s<sub>1</sub>, t<sub>1</sub> &isin; Q<sub>1</sub>,
      and s<sub>2</sub>, t<sub>2</sub> &isin; Q<sub>2</sub>, ((s<sub>1</sub>,
      s<sub>2</sub>), a, (t<sub>1</sub>, t<sub>2</sub>)) &isin; &delta; iff
      <ul>
        <li>(s<sub>1</sub>, a, t<sub>1</sub>) &isin; &delta;<sub>1</sub> and s<sub>2</sub> = t<sub>2</sub>, or</li>
        <li>(s<sub>2</sub>, a, t<sub>2</sub>) &isin; &delta;<sub>2</sub> and s<sub>1</sub> = t<sub>1</sub>.</li>
      </ul>
      </li>
    </ul> 
  In the synchronous setting, a mapping M from the propositions of the second
  automaton to the predicates on the propositions of the first automaton may
  be provided.
  In this case, the second automaton may have a different alphabet.
  Let M(l) for a literal l be M(l) if l is positive and &not;M(l) otherwise.
  Then, the synchronous product of A<sub>1</sub> and A<sub>2</sub> with the
  mapping M is P = (&Sigma;, Q, q<sub>0</sub>, &delta;, F) where
    <ul>
      <li>Q = Q<sub>1</sub> &times; Q<sub>2</sub>,</li>
      <li>q<sub>0</sub> = (q<sub>10</sub>, q<sub>20</sub>),</li>
      <li>for all a &isin; &Sigma;, s<sub>1</sub>, t<sub>1</sub> &isin; Q<sub>1</sub>,
      and s<sub>2</sub>, t<sub>2</sub> &isin; Q<sub>2</sub>, ((s<sub>1</sub>,
      s<sub>2</sub>), a, (t<sub>1</sub>, t<sub>2</sub>)) &isin; &delta; iff
      <ul>
      <li>(s<sub>1</sub>, a, t<sub>1</sub>) &isin; &delta;<sub>1</sub> and</li>
      <li>there is (s<sub>2</sub>, b, t<sub>2</sub>) &isin; &delta;<sub>2</sub>
      such that for all literal l &isin; b, M(l) is satisfied by a.</li>
      </ul>
      </li>
    </ul>
  For example, consider the following two B&uuml;chi automata.
  <div class="figure">
    <span class="medium"><img src="images/Product_A1.png" border="0" alt="The first automaton for the product" /></span>
    <span class="medium"><img src="images/Product_A2.png" border="0" alt="The second automaton for the product" /></span>
    <div class="caption">
      <span class="medium">A<sub>1</sub></span>
      <span class="medium">A<sub>2</sub></span>
    </div>
  </div>
  The synchronous product, asynchronous product, and synchronous product with
  a mapping are shown in the following.
  <div class="figure">
    <span class="medium"><img src="images/Product_Synchronous.png" border="0" alt="The synchronous product" /></span>
    <span class="medium"><img src="images/Product_Asynchronous.png" border="0" alt="The asynchronous product" /></span>
    <span class="medium"><img src="images/Product_Synchronous_Mapping.png" border="0" alt="The synchronous product with a mapping" /></span>
    <div class="caption">
      <span class="medium">The synchronous product</span>
      <span class="medium">The asynchronous product</span>
      <span class="medium">The synchronous product with a mapping M where M(p) = True and M(q) = p &or; q</span>
    </div>
  </div>  
  </li>
  <li><b>Intersection</b> - Take the intersection of two compatible automata.
  </li>
  <li><b>Union</b> - Take the union of two compatible automata.</li>
  <li>
    <b>Complement</b> - Complement the active automaton.
    <ul>
      <li><b>Classic Complementation</b> - Complement a classic finite word
      automaton.</li>
      <li><b>Kurshan's Construction</b> - Complement a DBW by Kurshan's
      construction [<a href="#references:kur87">Kur87</a>].</li>
      <li><b>Ramsey-Based Construction</b> - Complement an NBW by
      Ramsey-based construction [<a href="#references:buc62">Buc62</a>,
      <a href="#references:svw87">SVW87</a>].</li>
      <li><b>Safra's Construction</b> - Complement an NBW based on Safra's
      construction [<a href="#references:saf88">Saf88</a>].
      Schewe's history trees [<a href="#references:sch09b">Sch09b</a>] are also
      implemented as an option.</li>
      <li><b><a name="menu:automaton:complement:modifiedsafra">Modified Safra's
      Construction</a></b> - This is the same as Safra's construction, except
      that when constructing Safra trees, the steps of computing successors and
      creating sons are exchanged.</li>
      <li><b>Muller-Schupp Construction</b> - Complement an NBW based on
      Muller-Schupp construction [<a href="#references:ms95">MS95</a>,
      <a href="#references:atw06">ATW06</a>].</li>
      <li><b>Via Weak Alternating Parity Automaton</b> - Complement an NBW via
      a weak alternating parity automaton
      [<a href="#references:tho99">Tho99</a>].</li>
      <li>
        <b>Via Weak Alternating Automaton</b> - Complement an NBW via a weak
        alternating automaton [<a href="#references:kv01">KV01</a>].
      </li>
      <li>
        <b>Safra-Piterman Construction</b> - Complement an NBW based on
        Safra-Piterman construction [<a href="#references:pit06">Pit06</a>].
        Optimization heuristics in [<a href="#references:tfvt10">TFVT10</a>]
        are implemented.
        Schewe's history trees [<a href="#references:sch09b">Sch09b</a>] are also
        implemented as an option.
      </li>
      <li>
        <b>Rank-Based Construction</b> - Complement an NBW by rank-based
        construction [<a href="#references:kv01">KV01</a>] with optimizations
        proposed in [<a href="#references:sch09a">Sch09a</a>].
      </li>
      <li>
        <b>Slice-Based Construction</b> - Complement an NBW by the slice-based
        construction [<a href="#references:kw08">KW08</a>,
        <a href="#references:vw07">VW07</a>]. Optimization heuristics in
        [<a href="#references:tfvt10">TFVT10</a>] are also implemented.
        <br/><br/>
        Note: The slice-based construction is contributed by K&auml;hler and
        Wilke in [<a href="#references:kw08">KW08</a>].
        Its preliminary version is stated in
        [<a href="#references:vw07">VW07</a>]. 
      </li>
      <li><b>To Complement DBW</b> - Converts a DCW to a complement DBW.</li>
      <li><b>To Complement DCW</b> - Converts a DBW to a complement DCW.</li>
      <li><b>To Complement DMW</b> - Converts a DMW to a complement DMW.</li>
      <li><b>To Complement DRW</b> - Converts a DSW to a complement DRW.</li>
      <li><b>To Complement DSW</b> - Converts a DRW to a complement DSW.</li>
      <li><b>To Complement DPW</b> - Converts a DPW to a complement DPW.</li>
      <li><b>To Complement NABW</b> - Converts an NCW to a complement NABW.</li>
      <li><b>To Complement NACW</b> - Converts an NBW to a complement NACW.</li>
      <li><b>To Complement NAPW</b> - Converts an NAPW to a complement NAPW.</li>
    </ul>
  </li>
  <li>
    <b>Complement (Step-by-Step)</b> - Complement the active automaton
    step-by-step by various constructions.
    The toolbar items used to control the complementation algorithms are the
    same as in
    <a href="#editors:qptl:step_by_step">Step-by-Step Translation</a>.
    <ul>
      <li>
        <b>Safra's Construction</b> - NBW &rarr; DRW &rarr; complement DSW
        &rarr; complement NBW
      </li>
      <li>
        <b>Modified Safra's Construction</b> - NBW &rarr; DRW &rarr; complement DSW
        &rarr; complement NBW
      </li>
      <li>
        <b>Muller-Schupp Construction</b> - NBW &rarr; DRW &rarr; complement DSW
        &rarr; complement NBW
      </li>
      <li>
        <b>Via Weak Alternating Parity Automaton</b> - NBW &rarr;
        <a href="#terminology:napw">NAPW</a> &rarr; complement NBW
      </li>
      <li>
        <b>Via Weak Alternating Automaton</b> - NBW &rarr; complement
        <a href="#terminology:ucbw">UCBW</a> &rarr;
        complement <a href="#terminology:vwaa">VWAA</a> &rarr;
        complement NBW
      </li>
      <li>
        <b>Safra-Piterman Construction</b> - NBW &rarr; DPW &rarr; complement DPW
        &rarr; complement NBW
      </li>
      <li><b>Rank-Based Construction</b></li>
      <li><b>Slice-Based Construction</b></li>
    </ul>
  </li>
  <li>
    <b>Concatenation</b> - Concatenate an NFW and an &omega;-automaton such that
    the concatenation accepts the concatenation of the language of the NFW and
    the language of the &omega;-automaton.
  </li>
  <li>
    <b>Replacement</b> - Constructs an automaton M for a source automaton M<sub>1</sub>,
    a pattern automaton M<sub>2</sub> (&epsilon; &notin; L(M<sub>2</sub>)), and a
    replacement automaton M<sub>3</sub> such that L(M) = {w<sub>1</sub> c<sub>1</sub>
    w<sub>2</sub> c<sub>2</sub> &hellip; w<sub>k</sub> c<sub>k</sub> w<sub>k+1</sub> |
    k > 0, w<sub>1</sub> x<sub>1</sub> w<sub>2</sub> x<sub>2</sub> &hellip;
    w<sub>k</sub> x<sub>k</sub> w<sub>k+1</sub> &isin; L(M<sub>1</sub>),
    &forall; i, x<sub>i</sub> &isin; L(M<sub>2</sub>), w<sub>i</sub> does not
    contain any substring accepted by M<sub>2</sub>, c<sub>i</sub> &isin;
    L(M<sub>3</sub>)}.
    The implementation is based on [<a href="#references:ybci08">YBCI08</a>].
  </li>
  <li>
    <b>Reverse</b> - Reverse the transitions, initial states, and accepting
    states of an NFW such that the output accepts the reverse of the language
    of the input.
  </li>
  <li>
    <b>Simplify</b> - Simplify an automaton without changing its language.
    <ul>
      <li><b>By Reducing Unreachable/Dead States</b> - Remove
      <a href="#terminology:unreachable_state">unreachable states</a> and
      <a href="#terminology:dead_state">dead states</a>.</li>
      <li><b>By Reducing Alternating Connectors</b> - Remove unnecessary alternating
      connectors.</li>
      <li><b>By Pruning Fair Sets</b> - Simplify an NGBW by pruning fair sets
      [<a href="#references:sb00">SB00</a>].</li>
      <li><b>By Simulation</b> - Simplify an &omega;-automaton by direct simulation
      and reverse simulation [<a href="#references:sb00">SB00</a>].</li>
      <li><b>By Wring Approach</b> - Simplify an NGBW by pruning fair sets
      and simulation repeatedly until a fix-point is reached.</li>
      <li><b>By Delayed Simulation</b> - Simplify an NBW by delayed simulation
      [<a href="#references:ews01">EWS01</a>].
      Instead of small progress measure applied in the paper, we use McNaughton-Zielonka
      to solve delayed simulation games.</li>
      <li><b>By Fair Simulation</b> - Simplify an NBW by fair simulation
      [<a href="#references:gbs02">GBS02</a>].
      Instead of small progress measure applied in the paper, we use McNaughton-Zielonka
      to solve fair simulation games.
      Similar to small progress measure that can reuse previously computed progress measures,
      we use the results of McNaughton-Zielonka to reduce fair simulation games during the
      simplification.</li>
      <li><b>Through Rabin Index Computation</b> - Simplify the parity
      condition based on the computation of Rabin index
      [<a href="#references:cm99">CM99</a>].</li>
    </ul>
  </li>
  <li><b>Promela</b> - Display the Promela code of an NBW.</li>
</ul>

<h2><a name="menu:game">Game</a></h2>

<ul>
  <li>
    <b><a name="menu:solve">Solve</a></b> - Solve a game.
    <ul>
      <li>
        <b>By...</b> - Solve a game directly.
        A solved game with coloring annotations will be returned. If the annotated
        game is saved as a GFF file, the winning regions and winning strategies will
        also be saved.
        In the default installation, there are one solver for reachability games,
        one solver for B&uuml;chi games, and six solvers for parity games.
        <dl>
          <dt>Reachability Game Solvers</dt>
          <dd><ul>
            <li><b>Reachability</b></li>
          </ul></dd>
          <dt>B&uuml;chi Game Solvers</dt>
          <dd><ul>
            <li><b>Classical B&uuml;chi</b></li>
          </ul></dd>
          <dt>Parity Game Solvers</dt>
          <dd><ul>
            <li><b>Recursive</b>:
              a recursive algorithm based on induction on the number of parities
              [<a href="#references:zie98">Zie98</a>]. This implementation follows the
              description in [<a href="#references:kus01">Kus01</a>].
            </li> 
            <li><b>McNaughton-Zielonka</b>:
              an algorithm orignates from the work of McNaughton
              [<a href="#references:mcn93">McN93</a>] and was first presented for
              parity games by Zielonka [<a href="#references:zie98">Zie98</a>,
              <a href="#references:kus01">Kus01</a>].
              The implementation follows the description in
              [<a href="#references:jpz06">JPZ06</a>].
            </li>
            <li><b>Dominion Decomposition</b>:
              a deterministic subexponential algorithm based on dominion decomposition
              [<a href="#references:jpz06">JPZ06</a>].
            </li>
            <li><b>Small Progress Measure</b>:
              an implementation of the algorithm based on small progress measure
              [<a href="#references:jur00">Jur00</a>]. This implementation does
              include the optimizations described in [<a href="#references:jur00">Jur00</a>]. 
            </li>
            <li><b>Big Steps</b>:
              an algorithm which combines McNaughton's fixed point algorithm with a
              preprocessing step where a variant of the Jurdzi&#x0144;ski's small progress
              measure is applied to find dominions [<a href="#references:sch07">Sch07</a>].
              In this implementation, the winning strategies for a 3-parity subgame are
              partially computed.
            </li>
            <li><b>Global Optimization</b>:
              an algorithm which applies solver-independent global optimizations to the input
              parity game before delegating the game solving to another solver.
              The global optimizations include some heuristics described in
              [<a href="#references:fl09">FL09</a>].  
            </li>
          </ul></dd>
        </dl>
        <div class="note">The parity conditions in GOAL are min-even.</div>
      </li>
      <li>
        <b>Step-By-Step By...</b> - Solve a game step-by-step.
      </li>
    </ul>    
  </li>
  <li>
    <b>Convert</b> - Convert a game to another equivalent game.
  </li>
  <li><b>Product</b> - Take the synchronous product of a game and a finite state
  automaton. The game and the automaton must have the same type of alphabet and
  both have labels on transitions.
  The returned product will be a game with an acceptance condition that only
  depends on the automaton.
  A mapping from the propositions of the automaton to predicates on the
  propositions of the game may be provided.
  See the <a href="#menu:automaton:product">automaton product</a> for more details.
  </li>
</ul>

<h2><a name="menu:window">Window</a></h2>

<ul>
  <li><b>New Window</b> - Open a new GOAL window.</li>
  <li><b>Next Window</b> - Switch to the next window.</li>
  <li><b>Previous Window</b> - Switch to the previous window.</li>
  <li><b>Detach Tab</b> - Detach the active tab from the current window.</li>
  <li><b>Next Tab</b> - Switch to the next tab.</li>
  <li>
    <b>Previous Tab</b> - Switch to the previous tab.
    <div class="tip">
      Use Mac trackpad (swipe left or right with three fingers) to quickly switch among tabs.
    </div>
  </li>
  <li><b>Move Tab to Next Window</b> - Move the active tab to the next
  window.</li>
  <li><b>Move Tab to Previous Window</b> - Move the active tab to the previous
  window.</li>
  <li><b>Move Tab to...</b> - Move the active tab to a specified window.</li>
</ul>

<h2><a name="menu:help">Help</a></h2>

<ul>
  <li><b>Help Contents</b> - Display the help contents.</li>
  <li><b>Check for Updates</b> - Check for updates of GOAL.</li>
  <li><b>About</b> - Display information about the GOAL development team.</li>
</ul>

<!--
<ul>
  <li><b></b> - </li>
</ul>
-->

<!-- ================== Command-line Mode ================== -->

<h1><a name="cmd">Command-line Mode</a></h1>

<p class="plain">
The GOAL command-line mode can be either single mode or batch mode.
In the single mode, only one command can be executed each time.
In the batch mode, a sequence of commands can be executed.
A single command is an instr while a sequence of command is a block in the
grammar rules (see the <a href="#cmd:grammar">Grammar</a> section).
</p>

<p class="plain">
To execute a single command, the command and its arguments should be preceded
by the GOAL launcher (goal.bat on Windows and goal on UNIX).
To execute a sequence of commands, you can write GOAL scripts and use the
<a href="#cmd:batch">batch command</a> to execute the statements in the scripts.
For example, suppose the file SCRIPT contains a sequence of commands.
You can run these commands by invoking GOAL in the following way:
</p>
<pre>
  $ ./goal batch SCRIPT
</pre>
<p class="plain">
Unlike the execution of a single command, in a GOAL script, variables can be
used to capture the results of commands.
</p>

<p class="tip">
Set the shell variable GOAL_DEBUG to true to show exceptions thrown during execution.
</p>

<h2><a name="cmd:grammar">Grammar</a></h2>

<pre>
  block := ( stmt )*

  stmt := instr ";" | for_stmt | while_stmt | if_stmt | try_stmt

  instr :=
      "help" [ --html ] [ keyword ]
    | "interactive"
    | "exit"
    | "break" ( expr )?
    | "continue" ( expr )?
    | lval ("=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&amp;=" | "|=") ( expr | cmd_expr )
    | "(" lval ( "," lval )* ")" "=" ( expr | cmd_expr )
    | cmd_expr

  for_stmt := "for" lval "in" expr "do" block "done"

  while_stmt := "while" expr "do" block "done"

  if_stmt := "if" expr "then" block
             ( "elif" expr "then" block )*
             ( "else" block )?
             "fi"

  try_stmt := "try" "{" 
                block 
              "}" "catch" "(" lval ")" "{" 
                block
              "}"

  cmd_expr := cmd ( arg )*

  arg :=
      "-" string
    | "--" string
    | expr

  expr :=
      expr ( "\/" | "|" ) expr
    | expr ( "/\" | "&amp;" ) expr
    | expr "==" expr
    | expr "!=" expr
    | expr "&lt;" expr
    | expr "&gt;" expr
    | expr "&lt;=" expr
    | expr "&gt;=" expr
    | expr "+" expr
    | expr "-" expr
    | expr "*" expr
    | expr "/" expr
    | expr "%" expr
    | "-" expr
    | "!" expr
    | array
    | list
    | number
    | bool
    | string
    | lval
    | "time"
    | "(" expr ")"
    | "`" shell_cmd "`"

  array := "{" [ string ":" ] expr ("," [ string ":" ] expr)* "}"

  list := "[" expr (", " expr)* "]"

  number := int | float

  formula_or_lval := string | lval

  file_or_lval := file | string

  int_or_lval := int | lval

  string_or_lval := string | lval

  bool := "true" | "false"

  lval := "$" id

  int := (["0"-"9"])+

  float := (["0"-"9"])+ "." (["0"-"9"])+

  file := (["a"-"z","A"-"Z","0"-"9","_","-",".","/"])+

  id := ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9","_"] )*

  shell_cmd := ( ~["`","\n","\r"] )*

  AUTOMATON_TYPE := LOSNFW | LOSNREW | LOSNBW | LOSNCW | LOSNGBW | LOSNMW | LOSNRW | LOSNSW | LOSNPW |
                    DFW | DREW | DBW | DCW | DGBW | DMW | DRW | DSW | DPW |
                    NFW | NREW | NBW | NCW | NGBW | NMW | NRW | NSW | NPW |
                    DTBW | DTCW | DTGBW | DTMW | DTRW | DTSW | DTPW |
                    NTBW | NTCW | NTGBW | NTMW | NTRW | NTSW | NTPW |
                    DNFNABW | DNFNACW | DNFNAGBW | DNFNAMW | DNFNARW | DNFNASW | DNFNAPW |
                    CNFNABW | CNFNACW | CNFNAGBW | CNFNAMW | CNFNARW | CNFNASW | CNFNAPW |
                    DNFNTWABW | DNFNTWACW | DNFNTWAGBW | DNFNTWAMW | DNFNTWARW | DNFNTWASW | DNFNTWAPW |
                    CNFNTWABW | CNFNTWACW | CNFNTWAGBW | CNFNTWAMW | CNFNTWARW | CNFNTWASW | CNFNTWAPW |
                    UCW | WAA | WAPA | VWAA | TWVWAA | TWLWAA

  GAME_TYPE := DBG | DCG | DFG | DGBG | DMG | DPG | DREG | DRG | DSG |
               NBG | NCG | NFG | NGBG | NMG | NPG | NREG | NRG | NSG

  ALPHABET_TYPE := PROPOSITIONAL | CLASSICAL
</pre>

Each command expression cmd_expr starts with a command name followed by the
arguments.
The command names and the arguments for a particular command depend on what
<a href="#cmd:commands">commands</a> are installed. 

<h2><a name="cmd:variables">Variables</a></h2>

<p class="plain">
In GOAL scripts, every variable name should start with "$".
You don't need to declare the type of a variable before using it.
For example, below are some acceptable variable names:
</p>
<pre>
  $var
  $v0
  $v_0
</pre>

There are some special variables: $0, $1, $2, ..., $#, $*, and $@, which can
be used in a GOAL script.
$0 is the name of the GOAL script, $1 is the first argument, $2 is the second
argument, and so forth.
$# is the number of arguments.
$* and $@ denote all the arguments.

<h2><a name="cmd:lists">Lists</a></h2>

<p class="plain">
One way to create a list is to execute the readline command which reads a
file line by line.
Each element in the list is a line in the file.
For example, the following statement will read the file "input" and put each
line as an element in the list variable $list.
</p>
<pre>
  $list = readline "input";
</pre>

<h2><a name="cmd:arrays">Arrays (Maps)</a></h2>

<p class="plain">
An array is a map from an object convertible to a string to an object.
Basically, you can use any object as the index of an array.
For example, the following commands are acceptable.
</p>
<pre>
  $arr[0] = 0;
  $arr["number"] = 10;
  $arr = {
           1,
           "key" : "value" ,
           { "nested" : {2, 3, 4} }
         };
</pre>

<h2><a name="cmd:lists">Lists</a></h2>

<p class="plain">
A list is a sequence of items.
When iterating over a list, only list items will be returned.
This is different from arrays (maps) where indices are returned.
Below is an example of lists.
</p>
<pre>
  $algorithms = ["-m piterman -r", "-m rank -r", -m slice -r];
  for $alg in $algorithms do
    $o = complement --option $alg $aut;
  done
</pre>


<h2><a name="cmd:multiple_assignments">Multiple Assignments</a></h2>

<p class="plain">
A multiple assignment tries to split an object and assign the results to a set
of variables.
Note that the number of left elements should be less than or equal to the
number of right elements.
A string can be split by spaces, tabs, and newlines.
For example, the following statement will split the string into "1" and "2".
If you want to use delimiters rather than spaces, tabs, and newlines, you can
use the split command.
</p>
<pre>
  ($x, $y) = "1 2";
</pre>
<p class="plain">
The values of elements of a list can be assigned to a set of variables by the
following statement.
</p>
<pre>
  ($elm_1, $elm_2, ..., $elm_n) = $list
</pre>
<p class="plain">
The key set of an array can be assigned to a set of variables by the following
statement.
</p>
<pre>
  ($key_1, $key_2, ..., $key_n) = $arr
  $arr[$key_1] = 0;
  $arr[$key_2] = 1;
  ...
</pre>

<h2><a name="cmd:statements">Statements</a></h2>

<p class="plain">
A statement can be an instruction (command) with a trailing ";", a
for-statement, while-statement, an if-statement, or a try-statement.
A for-statement iterates on the elements of a list or the key set of an array.
For examples, below is a for-statements which iterates on a list.
</p>
<pre>
  $list = readline "input";
  for $elm in $list do
    echo $elm;
  done
</pre>
<p class="plain">
Below is a for-statements which iterates on an array.
</p>
<pre>
  for $key in $arr do
    echo $arr[$key];
  done
</pre>

<h2><a name="cmd:shell_commands">Shell Commands</a></h2>

<p class="plain">
A shell command can be invoked by putting the command between two `.
For example, the following command will invoke the shell command "seq 1 10"
and the variable $x will capture both the standard output and the error output
of this shell command.
</p>
<pre>
  $x = `seq 1 10`;
</pre>

<p class="plain">
Below is another example that prints numbers from 1 to 10 on the screen.
</p>
<pre>
  for $x in `seq 1 10` do
    echo $x;
  done
</pre>

<p class="plain">
A GOAL variable can be used in a shell command directly.
The interpreter of GOAL scripts will replace the GOAL variable with its
value in the shell command before executing the shell command.
For example, the following script will display "Hello World!" on the screen.
</p>
<pre>
$x = "Hello World!";
`echo $x`;
</pre>

<p class="plain">
If a variable in a shell command is not a declared GOAL variable,
the interpreter will not replace the variable as the variable may be a shell variable.
For example, the following script will display a random variable.
</p>
<pre>
`echo $RANDOM`;
</pre> 

<p class="plain">
If GOAL variables and shell variables have name conflicts, use "\" to force
the interpreter to treat a variable as a shell variable.
For example, the following script will output the string "random" followed
by a random number.  
</p>
<pre>
$RANDOM = "random";
`echo $RANDOM\$RANDOM`;
</pre>


<h2><a name="cmd:runtime_arguments">Runtime Arguments</a></h2>

<p class="plain">
The command-line argument "--option string" is reserved to specify arguments
known at runtime.
</p>
<p class="plain">
For example, the evaluation of
</p>
<pre>
cmd --option $x $file;
</pre>
<p class="plain">
is the same as the evaluation of
</p>
<pre>
cmd -opt1 -opt3 $file;
</pre>
<p class="plain">
if the value of $x is "-opt1 -opt3" at runtime.
</p>

<!-- ======================================================- -->
<!--          Generated Command Description (Start)           -->
<!-- ======================================================- -->



<h2><a name='cmd:commands'>COMMANDS</a></h2>

Below is the list of available commands.
<ul>
<li><a href='#cmd:acc'>acc</a></li>
<li><a href='#cmd:alphabet'>alphabet</a></li>
<li><a href='#cmd:aperiodic'>aperiodic</a></li>
<li><a href='#cmd:batch'>batch</a></li>
<li><a href='#cmd:classification'>classification</a></li>
<li><a href='#cmd:clone'>clone</a></li>
<li><a href='#cmd:close'>close</a></li>
<li><a href='#cmd:complement'>complement</a></li>
<li><a href='#cmd:concatenation'>concatenation</a></li>
<li><a href='#cmd:containment'>containment</a></li>
<li><a href='#cmd:convert'>convert</a></li>
<li><a href='#cmd:deterministic'>deterministic</a></li>
<li><a href='#cmd:determinization'>determinization</a></li>
<li><a href='#cmd:echo'>echo</a></li>
<li><a href='#cmd:emptiness'>emptiness</a></li>
<li><a href='#cmd:equivalence'>equivalence</a></li>
<li><a href='#cmd:generate'>generate</a></li>
<li><a href='#cmd:homomorphism'>homomorphism</a></li>
<li><a href='#cmd:import'>import</a></li>
<li><a href='#cmd:input'>input</a></li>
<li><a href='#cmd:intersection'>intersection</a></li>
<li><a href='#cmd:isomorphism'>isomorphism</a></li>
<li><a href='#cmd:layout'>layout</a></li>
<li><a href='#cmd:load'>load</a></li>
<li><a href='#cmd:minimization'>minimization</a></li>
<li><a href='#cmd:names'>names</a></li>
<li><a href='#cmd:omega'>omega</a></li>
<li><a href='#cmd:open'>open</a></li>
<li><a href='#cmd:parity'>parity</a></li>
<li><a href='#cmd:preference'>preference</a></li>
<li><a href='#cmd:product'>product</a></li>
<li><a href='#cmd:promela'>promela</a></li>
<li><a href='#cmd:property'>property</a></li>
<li><a href='#cmd:qptl'>qptl</a></li>
<li><a href='#cmd:readline'>readline</a></li>
<li><a href='#cmd:reduce'>reduce</a></li>
<li><a href='#cmd:replace'>replace</a></li>
<li><a href='#cmd:repository'>repository</a></li>
<li><a href='#cmd:reverse'>reverse</a></li>
<li><a href='#cmd:satisfiability'>satisfiability</a></li>
<li><a href='#cmd:save'>save</a></li>
<li><a href='#cmd:separation'>separation</a></li>
<li><a href='#cmd:seq'>seq</a></li>
<li><a href='#cmd:simequiv'>simequiv</a></li>
<li><a href='#cmd:simplify'>simplify</a></li>
<li><a href='#cmd:simulated'>simulated</a></li>
<li><a href='#cmd:sleep'>sleep</a></li>
<li><a href='#cmd:solve'>solve</a></li>
<li><a href='#cmd:split'>split</a></li>
<li><a href='#cmd:stat'>stat</a></li>
<li><a href='#cmd:test'>test</a></li>
<li><a href='#cmd:translate'>translate</a></li>
<li><a href='#cmd:union'>union</a></li>
<li><a href='#cmd:validity'>validity</a></li>
</ul>
The details of these commands are described in the following.


<div><h3><a name='cmd:acc'>- acc -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>acc - Maximize or minimize Buchi acceptance condition of a finite state
        automaton. Note that this operation will be applied directly on the
        input automaton.</dd>

<dt>SYNOPSIS</dt>
  <dd>acc [-max | -min] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Maximize or minimize Buchi acceptance condition of a finite state automaton.<br/>
  <br/>
  <table><tr valign='top'><td>-max</td> <td>Maximize the Buchi acceptance condition.</td></tr>
  <tr valign='top'><td>-min</td> <td>Minimize the Buchi acceptance condition.</td></tr>
  </table></dd>
<dt>EXAMPLE</dt>
<dd>  <pre>acc -max $aut;</pre></dd>
</dl>
    
<div><h3><a name='cmd:alphabet'>- alphabet -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>alphabet - Manipulate the alphabet of an automaton or a game.</dd>

<dt>SYNOPSIS</dt>
  <dd>alphabet -s [ -ap ] FILE_OR_LVAL</dd>
  <dd>alphabet -e EXPR [ -ap ] FILE_OR_LVAL</dd>
  <dd>alphabet -c EXPR [ -ap ] FILE_OR_LVAL</dd>
  <dd>alphabet -r EXPR [ -ap ] FILE_OR_LVAL</dd>
  <dd>alphabet -a EXPR [-R | -A | -S EXPR | -P EXPR | -ap ] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Manipulate the alphabet of an automaton (or a game). This operation is
  directly applied to the input automaton. The returned value is always the new
  alphabet of the automaton (or the new atomic propositions if -ap is present).<br/>
  <br/>
  <table><tr valign='top'><td>-s</td> <td>Simply return the alphabet of the input automaton or game.</td></tr>
  <tr valign='top'><td>-ap</td> <td>Return the atomic propositions (or classical symbols) instead of
      the alphabet.</td></tr>
  <tr valign='top'><td>-e</td> <td>Expand the alphabet by a list of propositions.</td></tr>
  <tr valign='top'><td>-c</td> <td>Contract the alphabet by removing a list of propositions.</td></tr>
  <tr valign='top'><td>-r</td> <td>Rename the propositions based on a map from a proposition to its new name.</td></tr>
  <tr valign='top'><td>-a</td> <td>Abstract the alphabet based on a map from a predicate to its definition.</td></tr>
  <tr valign='top'><td>-R</td> <td>Retain the transition symbols in alphabet abstraction.</td></tr>
  <tr valign='top'><td>-A</td> <td>Only annotate the transitions with properties specified by -S and -P.</td></tr>
  <tr valign='top'><td>-S</td> <td>Specify the name of the property that will store the symbols on the
     transitions in alphabet abstraction.</td></tr>
  <tr valign='top'><td>-P</td> <td>Specify the name of the property that will store the evaluations of the
     predicates in alphabet abstraction.</td></tr>
  </table></dd>
<dt>EXAMPLE</dt>
<dd><pre>  alphabet -e "r" aut.gff
  alphabet -c "p" aut.gff
  alphabet -r "p=&gt;r,q=&gt;s" aut.gff
  alphabet -a "r=&gt;p/\q" aut.gff
  alphabet -a "r=&gt;p/\q" -A -P "Predicates" aut.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:aperiodic'>- aperiodic -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>aperiodic - Test the aperiodicity of an automaton or a language.</dd>

<dt>SYNOPSIS</dt>
  <dd>aperiodic [-A | -a | -s] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Return "true" if (1) -A is specified and the input automaton is aperiodic or
  (2) -A is not specified and the language of the automaton is aperiodic.
  Return "false" otherwise.<br/>
  <br/>
  <table><tr valign='top'><td>-A</td> <td>Test the aperiodicity of the automaton rather than the language of the
     automaton. By default, this command tests the aperiodicity of the language
     of the input automaton.</td></tr>
  <tr valign='top'><td>-a</td> <td>Test the aperiodicity of the automaton first. By default, this option is
     off.</td></tr>
  <tr valign='top'><td>-s</td> <td>Skip rejected strings. By default, this option is off.</td></tr>
  </table></dd>
<dt>EXAMPLE</dt>
  <dd><pre>aperiodic -a -s aut.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:batch'>- batch -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>batch - Execute a script.</dd>

<dt>SYNOPSIS</dt>
  <dd>batch FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Execute the statement in a GOAL script. If the argument is not a file, it
  will be parsed as a statement.</dd>

<dt>EXAMPLE</dt>
<dd><pre>  batch script
  batch "echo Hello; echo World;"</pre></dd>
</dl>
    
<div><h3><a name='cmd:classification'>- classification -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>classification - Classify an automaton or a QPTL formula based on the
  Manna-Pnueli Temporal Hierarchy.</dd>

<dt>SYNOPSIS</dt>
  <dd>classification [-c | -t | -s] [FILE_OR_LVAL | FORMULA_OR_LVAL]</dd>

<dt>DESCRIPTION</dt>
  <dd>Classify an automaton or a QPTL formula based on the Manna-Pnueli temporal
  hierarchy.<br/>
  <br/>
  <table><tr valign='top'><td>-c</td> <td>Use DCW instead of DMW to construct DBW. By default, this options is off.</td></tr>
  <tr valign='top'><td>-t</td> <td>Classify in a top-down manner. By default, this option is off.</td></tr>
  <tr valign='top'><td>-s</td> <td>Return classes of the Temporal Hierarchy such that a class &kappa; is returned
     if and only if the QPTL formula is a standard &kappa;-formula.</td></tr>
</table></dd>
<dt>EXAMPLE</dt>
  <dd><pre>classification "[](p U q) U q"</pre></dd>
</dl>
    
<div><h3><a name='cmd:clone'>- clone -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>clone - Make a clone of an object.</dd>

<dt>SYNOPSIS</dt>
  <dd>clone EXPR</dd>

<dt>DESCRIPTION</dt>
  <dd>Make a clone of an object.</dd>

<dt>EXAMPLE</dt>
  <dd><pre>clone $aut;</pre></dd>
</dl>
    
<div><h3><a name='cmd:close'>- close -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>close - Close a GOAL window.</dd>

<dt>SYNOPSIS</dt>
  <dd>close [-f] INT_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Close the GOAL window with a specified index.<br/>
  <br/>
  <table><tr valign='top'><td>-f</td> <td>Close the window without saving changes.</td></tr>
</table></dd>
<dt>EXAMPLE</dt>
  <dd><pre>close 1</pre></dd>
</dl>
    
<div><h3><a name='cmd:complement'>- complement -</a></h3></div>
<dl>

<dt>NAME</dt>
  <dd>complement - Complement an automaton.</dd>

<dt>SYNOPSIS</dt>
  <dd>complement [-m ALGORITHM | -o FILE_OR_LVAL | -s EXPR | -t EXPR | 
             ALGORITHM_DEPENDENT_ARGUMENTS] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Compute the complement of the input automaton by a specified complementation
  algorithm.</dd>
  
<dt>COMMON ARGUMENTS</dt>
  <dd><table><tr valign='top'><td>-m</td> <td>Choose the complementation algorithm. Below is a list of available
     complementation algorithms:
<ul>       <li>classic</li>
       <li>deterministic</li>
       <li>kurshan</li>
       <li>modifiedsafra</li>
       <li>ms</li>
       <li>piterman</li>
       <li>ramsey</li>
       <li>rank</li>
       <li>safra</li>
       <li>slice</li>
       <li>waa</li>
       <li>wapa</li>
</ul>     Default complementation algorithms for automaton types:
<ul>       <li>NFW: classic</li>
       <li>NBW: piterman</li>
</ul></td></tr>  <tr valign='top'><td>-o</td> <td>Output to a designated file. By default, the result will show on the
     screen.</td></tr>
  <tr valign='top'><td>-s</td> <td>Stop the complementation algorithm at a given stage and output the
     intermediate result. If the stage is 0, the complementation algorthm
     will be performed completely. Kurshan's construction does not have
     middle stage.</td></tr>
  <tr valign='top'><td>-t</td> <td>Give the timeout (second). By default, the timeout is 0, i.e., no
     timeout.</td></tr></table></dd>

<dt>ARGUMENTS FOR modifiedsafra</dt>
<dd>  <table><tr valign='top'><td>-atl</td> <td>  Apply the heuristic of simplifying accepting true loops.
         By default, this option is off.</td></tr>
  <tr valign='top'><td>-sa</td> <td>   Apply the heuristic of marking nodes that have only accepting
         successors green. By default, this option is off.</td></tr></table></dd>

<dt>ARGUMENTS FOR piterman</dt>
<dd>  <table><tr valign='top'><td>-ht</td> <td>  Use Schewe's history trees instead of compact Safra trees. By default,          this option is off.</td></tr>
  <tr valign='top'><td>-eq</td> <td>  Apply local optimization of merging equivalent states during the.
        conversion from an NBW to an equivalent NBW. By default, this option
        is off.</td></tr>
  <tr valign='top'><td>-macc</td> <td>Maximize the accepting set of the target automaton.
        By default, this option is off.</td></tr>
  <tr valign='top'><td>-sim</td> <td> Simplify the complement NPW by simulation relations.
        By default, this option is off.</td></tr>
  <tr valign='top'><td>-sp</td> <td>  Simplify the parity condition based on the computation of Rabin index.
        By default, this option is off.</td></tr>
  <tr valign='top'><td>-ro</td> <td>  Reduce transitions in the conversion from NPW to NBW based on
        the idea in the slice-based construction. By default, this option is
        off.</td></tr>
  <tr valign='top'><td>-r</td> <td>   Remove unreachable and dead states from the complement. By default,
        this option is off.</td></tr></table></dd>

<dt>ARGUMENTS FOR ramsey</dt>
<dd>  <table><tr valign='top'><td>-macc</td> <td>Maximize the accepting set of the target automaton.
        By default, this option is off.</td></tr>
  <tr valign='top'><td>-min</td> <td> Minimize the intermediate DFW. By default, this option is off</td></tr>
  <tr valign='top'><td>-r</td> <td>   Remove unreachable and dead states from the complement. By default,
        this option is off.</td></tr></table></dd>

<dt>ARGUMENTS FOR rank</dt>
<dd>  <table><tr valign='top'><td>-r</td> <td>   Remove unreachable and dead states from the resulting automaton.
        By default, this option is off.</td></tr>
  <tr valign='top'><td>-tr</td> <td>  Apply tight rank construction. By default, this option is off.</td></tr>
  <tr valign='top'><td>-cp</td> <td>  Apply turn wise cut-point construction. By default, this option is off.</td></tr>
  <tr valign='top'><td>-ro</td> <td>  Apply the option of reducing outdegree. This implies tight rank. By
        default, this option is off.</td></tr>
  <tr valign='top'><td>-macc</td> <td>Maximize the accepting set of the target automaton. By default, this
        option is off.</td></tr></table></dd>

<dt>ARGUMENTS FOR safra</dt>
<dd>  <table><tr valign='top'><td>-ht</td> <td>   Use Schewe's history trees instead of compact Safra trees. By default,          this option is off.</td></tr>
  <tr valign='top'><td>-atl</td> <td>  Apply the heuristic of simplifying accepting true loops.
         By default, this option is off.</td></tr>
  <tr valign='top'><td>-sa</td> <td>   Apply the heuristic of marking nodes that have only accepting
         successors green. By default, this option is off.</td></tr></table></dd>

<dt>ARGUMENTS FOR slice</dt>
<dd>  <table><tr valign='top'><td>-p</td> <td>   Use the preliminary version.</td></tr>
  <tr valign='top'><td>-r</td> <td>   Remove unreachable and dead states from the resulting automaton. By
        default, this option is off.</td></tr>
  <tr valign='top'><td>-cp</td> <td>  Apply turn wise cut-point construction. By default, this option is off.</td></tr>
  <tr valign='top'><td>-ro</td> <td>  Apply the option of reducing outdegree. By default, this option is off.</td></tr>
  <tr valign='top'><td>-macc</td> <td>Maximize the accepting set of the target automaton. By default, this
        option is off.</td></tr>
  <tr valign='top'><td>-tt</td> <td>  Make the transition relation of the input automaton total. By default,
        this option is off.</td></tr>
  <tr valign='top'><td>-bfs</td> <td> Use breadth-first search when expanding the complement automaton.
        By default, depth-first search will be used.</td></tr>
  <tr valign='top'><td>-madj</td> <td>Merge adjacent 0-sets or *-sets. By default, this option is off.</td></tr>
  <tr valign='top'><td>-eg</td> <td>  Apply the enhanced guessing. By default, this option is off.</td></tr></table></dd>

<dt>EXAMPLE</dt>
<dd><pre>  complement -m classic -o b.gff a.gff
  complement -m deterministic a.gff</pre></dd>
</dl>

<div><h3><a name='cmd:concatenation'>- concatenation -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>concatenation - Concatenate an NFW and an &omega;-automaton or objects as a string.</dd>

<dt>SYNOPSIS</dt>
  <dd>concatenation [-o FILE_OR_LVAL] FILE_OR_LVAL FILE_OR_LVAL</dd>
  <dd>concatenation [-g EXPR] LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Concatenate an NFW and an &omega;-automaton such that the result accepts the
  concatenation of the language of the NFW and the language of the omega
  automaton. This command can also be used to concatenate the string
  representations of objects.<br/>
  <br/>
  <table><tr valign='top'><td>-o</td> <td>Output to a designated file. By default, the result will show on the
     screen.</td></tr>
  <tr valign='top'><td>-g</td> <td>The glue between each string representation of the objects.</td></tr>
  </table></dd>
<dt>EXAMPLE</dt>
<dd><pre>  concatenation -o c.gff a.gff b.gff
  concatenation -g ", " $objs</pre></dd>
</dl>
    
<div><h3><a name='cmd:containment'>- containment -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>containment - Check whether an automaton is contained in another.</dd>

<dt>SYNOPSIS</dt>
  <dd>containment [-m CONTAINMENT_ALG] [-macc | -pre | -sim | -rand ]
              FILE_OR_LVAL FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Check whether the first input automaton is contained in the second one.
  Return "(true, null)" if it is the case, and "(false, CE)" otherwise where
  CE is a counterexample.<br/>
  <br/>
  <table><tr valign='top'><td>-m</td> <td>Specify the algorithm used for checking containment. The value can be
     naive, ms, safra, modifiedsafra, piterman, slice. By
     default, naive is be used.</td></tr>
  <tr valign='top'><td>-macc</td> <td>Maximize the acceptance sets of the input automata. This option applies
        to ms, safra, modifiedsafra, piterman, and slice. By default, this
        option is off.</td></tr>
  <tr valign='top'><td>-pre</td> <td>Simplify the input automata by simulation relations. This option applies
       to ms, safra, modifiedsafra, piterman, and slice. By default, this
       option is off.</td></tr>
  <tr valign='top'><td>-sim</td> <td>Utilize the simulation relation between the input automata. This option
       applies to safra, modifiedsafra, ms, piterman, and slice. By default,
       this option is off.</td></tr>
  <tr valign='top'><td>-rand</td> <td>Apply random search. This option applies to ms, safra, modifiedsafra,
        piterman, and slice. By default, this option is off.</td></tr>
</table></dd>
<dt>EXAMPLE</dt>
<dd><pre>  containment a.gff b.gff
  containment -m piterman a.gff b.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:convert'>- convert -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>convert - Convert an automaton into another type of automaton, a regular
  expression, an &omega;-regular expression, or a game, or convert a game into
  a game of another type.</dd>

<dt>SYNOPSIS</dt>
  <dd>convert [-t AUTOMATON_TYPE | -o FILE_OR_LVAL] FILE_OR_LVAL</dd>
  <dd>convert [-t GAME_TYPE | -o FILE_OR_LVAL] FILE_OR_LVAL</dd>
  <dd>convert [-t ALPHABET_TYPE | -o FILE_OR_LVAL] FILE_OR_LVAL</dd>
  <dd>convert -t game -p FILE_OR_LVAL [-o FILE_OR_LVAL] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Convert an automaton into another type of automaton, a regular expression,
  or an &omega;-regular expression, or convert a game into another type of game.<br/>
  <br/>
  <table><tr valign='top'><td>-t</td> <td>Specify the target type of the automaton or game to be converted.</td></tr>
  <tr><td>-o</td> <td>Write the result to the specified file.</td></tr>
  <tr><td>-p</td> <td>Specify the propositions controlled by Player P0. The expacted value of
     this argument is a string of comma-separated propositions.</td></tr>
</table></dd>
<dt>EXAMPLE</dt>
<dd><pre>  convert -t nbw -o output.gff input.gff
  convert -t re nfw.gff
  convert -t ore nbw.gff
  convert -t npg game.gff
  convert -t game -p "ack1,ack2" dpw.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:deterministic'>- deterministic -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>deterministic - Test if an automaton is syntactically deterministic or
  semantically deterministic. By default, syntactic determinism is tested.</dd>

<dt>SYNOPSIS</dt>
  <dd>deterministic [-t EXPR] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>By default, return "true" if the input automaton is syntactically
  deterministic, or "false" otherwise. If "-t semantics" is specified, return
  "true" if the input automaton is semantically deterministic.
  <br/>
  <table><tr valign='top'><td>-t</td> <td>The argument can be either "syntax" or "semantics" which specify whether
     syntactic determinism or semantic determinism is tested.</td></tr></table>
  </dd>
<dt>EXAMPLE</dt>
  <dd><pre>deterministic abc.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:determinization'>- determinization -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>determinization - Determinize a nondeterministic automaton to an equivalent
  deterministic automaton.</dd>

<dt>SYNOPSIS</dt>
  <dd>determinization [-m DETERMINIZATION_ALG | -o FILE_OR_LVAL] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Compute the determinization of the input automaton. The type of the resulting
  automaton depends on the algorithm you choose. When the algorithm is landweber
  or bk09, the returned automaton may be null if the input automaton is not
  DBW-recognizable.<br/>
  <br/>
  <table><tr valign='top'><td>-m</td> <td>Choose the determinization algorithm. Below is a list of available
     parameters and their corresponding determinization algorithms:<br/><ul>
       <li>classic: determinizing a classic automaton to a deterministic classic
         automaton.</li>
       <li>safra: Safra's Construction for determinizing NBW to DRW.</li>
       <li>modifiedsafra: Modified Safra's Construction for determinizing NBW to
         DRW.</li>
       <li>ms: Muller-Schupp Construction for determinizing NBW to DRW.</li>
       <li>piterman: Safra-Piterman Construction for determinizing NBW to DPW.</li>
       <li>landweber: Landweber's Construction for determinizing DMW to DBW.</li>
       <li>bk09: The construction through DCW in [BK09].</li>
</ul>
     By default, classic will be used for classic automaton and Safra's
     construction will be used for B&uuml;chi automaton.</td></tr>
  <tr valign='top'><td>-o</td> <td>Output to a designated file. By default, the result will show on the
     screen.</td></tr>
  <tr valign='top'><td>-ht</td> <td>Use Schewe's history trees. This option is available for Safra's
       construction and Safra-Piterman construction. Some optimizations for
       Safra's construction may not be implemented for history trees. By
       default, this option is off.</td></tr>
  <tr valign='top'><td>-atl</td> <td>Apply the heuristic of simplifying accepting true loops.
       This options applies to the Safra's construction and the modified
       Safra's construction. By default, this options is off.</td></tr></table></dd>

<dt>EXAMPLE</dt>
<dd><pre>  determinization -m classic -o b.gff a.gff
  determinization -m safra -o b.gff a.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:echo'>- echo -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>echo - Output objects on the screen.</dd>

<dt>SYNOPSIS</dt>
  <dd>echo [ -n | -spin | -unicode ] [ EXPR ... ]</dd>

<dt>DESCRIPTION</dt>
  <dd>Output an expression on the screen.<br/>
  <br/>
  <table><tr valign='top'><td>-n</td> <td>Do not output the trailing newline.</td></tr>
  <tr valign='top'><td>-spin</td> <td>Output a formula in SPIN format.</td></tr>
  <tr valign='top'><td>-unicode</td> <td>Output a formula in unicode.</td></tr>
</table></dd>
<dt>EXAMPLE</dt>
  <dd><pre>echo "Hello World!"</pre></dd>
</dl>
    
<div><h3><a name='cmd:emptiness'>- emptiness -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>emptiness - Check emptiness of an automaton.</dd>

<dt>SYNOPSIS</dt>
  <dd>emptiness FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Return "true" if the input automaton is empty, and "false" otherwise.</dd>

<dt>EXAMPLE</dt>
  <dd><pre>emptiness abc.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:equivalence'>- equivalence -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>equivalence - Check whether two automata accept the same language.</dd>

<dt>SYNOPSIS</dt>
  <dd>equivalence FILE_OR_LVAL FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Check whether the first input automaton and the second one accept the same
  language. Return "true" if it is the case, and "false" otherwise.</dd>

<dt>EXAMPLE</dt>
  <dd><pre>equivalence a.gff b.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:generate'>- generate -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>generate - Generate a finite state automaton, QPTL formulae, an integer, or
  a floating point number randomly.</dd>

<dt>SYNOPSIS</dt>
  <dd>generate -t fsa [-a EXPR | -A EXPR | -m EXPR | -s EXPR | -n EXPR | -pt EXPR |
                  -ps EXPR | -pa EXPR | -dt EXPR | -da EXPR | -r | -S]</dd>
  <dd>generate -t game [-a EXPR | -A EXPR | -m EXPR | -s EXPR | -n EXPR | -pt EXPR |
                  -ps EXPR | -pa EXPR | -dt EXPR | -da EXPR | -pr | -r | -S]</dd>
  <dd>generate -t qptl [-l EXPR | -n EXPR | -r | -of | -mcp | -w EXPR EXPR EXPR |
                  -plain | -spin] EXPR</dd>
  <dd>generate -t int EXPR [ EXPR ]</dd>
  <dd>generate -t float EXPR [ EXPR ]</dd>

<dt>DESCRIPTION</dt>
  <dd>Randomly generate a finite state automaton, QPTL formulae, an integer, or
  a floating point number. When generating random integers or random floating
  point numbers, the range of the random numbers must be specified as (1) a
  minimal number (inclusive) and a maximal number (exclusive), or (2) a maximal
  number (exclusive), in which case the minimal number will be 0 (inclusive).<br/>
  <br/>
  <table><tr valign='top'><td>-a</td> <td>Specify the type of the structure. The type can be nfw, nrew, nbw,
     ncw, ngbw, nmw, nrw, nsw, npw, ntbw, ntgbw, ntmw,
     ntrw, ntsw, ntpw, dfw, drew, dbw, dcw, dgbw, dmw,
     drw, dsw, dpw, dtbw, dtgbw, dtmw, dtrw, dtsw, or dtpw
     for finite state automata. The type can be nfg, nreg, nbg, ncg,
     ngbg, nmg, nrg, nsg, npg, dfg, dreg, dbg, dcg, dgbg,
     dmg, drg, dsg, or dpg for games. The default automaton type is nbw
     while the default game type is nbg.</td></tr>
  <tr valign='top'><td>-A</td> <td>Specify the alphabet type. The type can be propositional or
     classical. The default type is propositional alphabet.</td></tr>
  <tr valign='top'><td>-m</td> <td>Specify the generation model of transitions and acceptance condition. The
     model can be probability or density. The default model is probability.</td></tr>
  <tr valign='top'><td>-s</td> <td>Specify the desired number of states in the generated omega automaton.
     The default value is 5.</td></tr>
  <tr valign='top'><td>-n</td> <td>Specify the number of atomic propositions. The default value is
     2 (atomic propositions). In random formulae generation, each atomic
     proposition will occur at least once in each formula.</td></tr>
  <tr valign='top'><td>-pt</td> <td>Specify the probability of whether there should be transitions
      from one state to another state. The value of the probability should
      be in the range from 0 to 1. By default, the probability is decided
      randomly every time.</td></tr>
  <tr valign='top'><td>-ps</td> <td>Specify the probability of labeling a symbol on a transition.
      Assume there n states, the alphabet size is m, the probability
      specified by -pt is p1, and  the probability specified by -ps is p2.
      The expected number of transitions is (n * n * p1) * (m * p2).</td></tr>
  <tr valign='top'><td>-pa</td> <td>Specify the probability of adding a state to an acceptance set.</td></tr>
  <tr valign='top'><td>-dt</td> <td>Specify the transition density. The default value is 0.</td></tr>
  <tr valign='top'><td>-da</td> <td>Specify the acceptance density. The default value is 0.</td></tr>
  <tr valign='top'><td>-pr</td> <td>Specify the ratio of (player 0 states / player 1 states).</td></tr>
  <tr valign='top'><td>-r</td> <td>In random automata generation, this means to count the number of states
     after removing unreachable and dead states. Note that if this option is
     on, it will take longer to generate an automaton. In random formulae
     generation, this means to allow repeated formulae generated. By default,
     GOAL does not generate the same formula twice.</td></tr>
  <tr valign='top'><td>-S</td> <td>Count the number of states after applying simulation simplification.
     Note that if this option is on, it will take longer to generate an
     automaton.</td></tr>
  <tr valign='top'><td>-l</td> <td>Specify the length of the generated formulae.</td></tr>
  <tr valign='top'><td>-w</td> <td>Specify the weights of operators which determine the probability of
     choosing which operator. The following three values are weight of boolean
     commands, weight of future operators, and weight of past operators. For
     example, the posibility of choosing a boolean operator is
     (WEIGHT_BOOLEAN/(WEIGHT_BOOLEAN+WEIGHT_FUTURE+WEIGHT_PAST)). At least
     one of them must have a positive weight. None of them can have a
     negative weight.</td></tr>
  <tr valign='top'><td>-of</td> <td>The outmost operator of every generated formula is a future operator.</td></tr>
  <tr valign='top'><td>-mcp</td> <td>Every generated formula must contain at least one past operator if the
       weight of past operators is greater than 1.</td></tr>
  <tr valign='top'><td>-plain</td> <td>Output formulae in plain text instead of GFF.</td></tr>
  <tr valign='top'><td>-spin</td> <td>Output formulae that can be accepted by SPIN.</td></tr>
</table></dd>
<dt>EXAMPLE</dt>
<dd><pre>  generate -t fsa -a nbw -s 10 -n 3
  generate -t fsa -a npw -s 5 -n 2 -as 4
  generate -t qptl -w 1 2 0 -n 2 -l 8 10
  generate -t int 0 10</pre></dd>
</dl>
    
<div><h3><a name='cmd:homomorphism'>- homomorphism -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>homomorphism - Check if the first automaton is homomorphic to the second
  automaton.</dd>

<dt>SYNOPSIS</dt>
  <dd>homomorphism FILE_OR_LVAL FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Check if the first automaton is homomorphic to the second automaton. Return a
  homomorphism if it is the case, and "false" otherwise.</dd>

<dt>EXAMPLE</dt>
  <dd><pre>homomorphism a.gff b.gff</pre></dd>
</dl>

<div id='cmd:import'><h3><a name='cmd:import'>- Import -</a></h3>

<dl>
<dt>NAME</dt>
  <dd>import - Import objects from a string.</dd>

<dt>SYNOPSIS</dt>
  <dd>import [-c EXPR] LVAL STRING_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Import objects from a string.<br/>
  <br/>
  <table><tr valign='top'><td>-c</td> <td>A codec used to decode the specified string.</td></tr>
  </table></dd>
<dt>EXAMPLE</dt>
  <dd><pre>import -c BA a.gff "[0]\nb,[0]-&gt;[1]\na,[1]-&gt;[1]\n[1]"</pre></dd>
</dl>
</div>


<div><h3><a name='cmd:input'>- input -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>input - Check if a word is accepted by an automaton.</dd>

<dt>SYNOPSIS</dt>
  <dd>input FILE_OR_LVAL STRING_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Check if a word is accepted by an automaton. Return "true" if the word
  is accepted, and "false" otherwise.<br/>
  </dd>

<dt>EXAMPLE</dt>
<dd><pre>  input a.gff "(p ~q)(p q){ (~p ~q) }"
  input a.gff "(a)(b){ (a)(b)(a) }"</pre></dd>
</dl>
    
<div><h3><a name='cmd:intersection'>- intersection -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>intersection - Compute the intersection of the two input automata.</dd>

<dt>SYNOPSIS</dt>
  <dd>intersection [-o FILE_OR_LVAL] FILE_OR_LVAL FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Compute the intersection (synchronous product) of the two input automata
  and output the resulting automaton.<br/>
  <br/>
  <table><tr valign='top'><td>-o</td> <td>Output to a designated file. By default, the result will show on the
     screen.</td></tr>
  </table></dd>
<dt>EXAMPLE</dt>
  <dd><pre>intersection -o c.gff a.gff b.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:isomorphism'>- isomorphism -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>isomorphism - Check if two automaton are isomorphic.</dd>

<dt>SYNOPSIS</dt>
  <dd>isomorphism FILE_OR_LVAL FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Check if two automata are isomorphic. Return an isomorphism if it is the case,
  and "false" otherwise.</dd>

<dt>EXAMPLE</dt>
  <dd><pre>isomorphism a.gff b.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:layout'>- layout -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>layout - Layout an automaton or the active automaton in a GOAL window.</dd>

<dt>SYNOPSIS</dt>
  <dd>layout [-m EXPR] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Specify a window ID to lay out the active automaton in the window or specify
  an automaton to lay out it offscreen.<br/>
  <br/>
  <table><tr valign='top'><td>-m</td> <td>Specify the layout algorithm. Use the command "names layout" to see all
     available layout algorithms.</td></tr>
  </table></dd>
<dt>EXAMPLE</dt>
  <dd><pre>layout 1
  layout -m "Circle Layout" aut.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:load'>- load -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>load - Load a file into a variable. If the file contains multiple objects, the
  variable will be a list.</dd>

<dt>SYNOPSIS</dt>
  <dd>load [-c EXPR] [ LVAL ] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Load a file into a variable.<br/>
  <br/>
  <table><tr valign='top'><td>-c</td> <td>Specify the codec used to decode the object. By default, the first
     applicable codec will be used. Use the command "names codec" to see al
     available codecs.</td></tr></table></dd>

<dt>EXAMPLE</dt>
<dd><pre>  load $omega input.gff
  $x = load input.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:minimization'>- minimization -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>minimization - Compute the minimization of the input classic automaton.</dd>

<dt>SYNOPSIS</dt>
  <dd>minimization [-o FILE_OR_LVAL] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Compute the minimization of the input classic automaton.<br/>
  <br/>
  <table><tr valign='top'><td>-o</td> <td>Output to a designated file. By default, the result will show on the
     screen.</td></tr></table></dd>

<dt>EXAMPLE</dt>
  <dd><pre>minimization -o b.gff a.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:names'>- names -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>names - Print names of some extensions.</dd>

<dt>SYNOPSIS</dt>
  <dd>names EXPR</dd>

<dt>DESCRIPTION</dt>
  <dd>Print names of some extensions and types. The argument can be "alphabet",
  "automaton", "codec", "command", "complement", "game", "layout", "player",
  "simulation", "simulation2", "solver", or "translate".<br/></dd>

<dt>EXAMPLE</dt>
  <dd><pre>names codec</pre></dd>
</dl>
    
<div><h3><a name='cmd:omega'>- omega -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>omega - Performing the &omega; operation on an NFW.</dd>

<dt>SYNOPSIS</dt>
  <dd>omega FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Given an NFW, create an NBW such that a word is accepted by the NBW iff the
  word can be partitioned into segments and every word segment is accepted by
  the NFW.</dd>

<dt>EXAMPLE</dt>
  <dd><pre>omega abc.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:open'>- open -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>open - Open a file as an editable object in a GOAL window.</dd>

<dt>SYNOPSIS</dt>
  <dd>open [-w ID] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Open a file as an editable object in a GOAL window. The return value is the
  index of the GOAL window.<br/>
  <br/>
  <table><tr valign='top'><td>-w</td> <td>Specified the GOAL window for the opened editable object.</td></tr></table></dd>

<dt>EXAMPLE</dt>
  <dd><pre>open input.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:parity'>- parity -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>parity - Operations on parity conditions.</dd>

<dt>SYNOPSIS</dt>
  <dd>parity convert EXPR EXPR FILE_OR_LVAL</dd>
  <dd>parity compress FILE_OR_LVAL</dd>
  <dd>parity propagate FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Convert the interpretation of parity conditions, compress parity conditions,
  or propagate parities of states in a parity condition. For the conversion
  of parity interpretations, the first argument is the source parity
  interpretation, the second argument is the target parity interpretation, and
  the third argument is a parity automaton (or a parity game).</dd>

<dt>EXAMPLE</dt>
<dd><pre>  parity convert min-even max-even aut.gff
  parity compress aut.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:preference'>- preference -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>preference - Return user preferences or adjust user preferences at runtime.</dd>

<dt>SYNOPSIS</dt>
  <dd>preference [ EXPR [ EXPR ] ]</dd>

<dt>DESCRIPTION</dt>
  <dd>Return user preferences or adjust user preferences at runtime. The first
  argument is the name of the preference. The second argument is the new value
  of the preference. If the second argument is absent, the current value of the
  user preference with the specified name will be returned. If both arguments
  are absent, all user preferences and their values will be returned.</dd>

<dt>EXAMPLE</dt>
<dd><pre>  preference ComplementAlgorithm
  preference LayoutAlgorithm org.svvrl.goal.core.layout.KKLayout</pre></dd>
</dl>
    
<div><h3><a name='cmd:product'>- product -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>product - Take the product of the two finite state automata or a game and a
            finite state automaton.</dd>

<dt>SYNOPSIS</dt>
  <dd>product [-o FILE_OR_LVAL | -m EXPR | -a ] FILE_OR_LVAL FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Take the product of two finite state automata or a game and a finite state
  automaton. The inputs must have the same type of alphabet and have labels on
  transitions. The structure of the product will be the same as that of the
  first automaton (or game). The acceptance condition of the product only
  depends on the second automaton.<br/>
  <br/>
  <table><tr valign='top'><td>-o</td> <td>Output to a designated file. By default, the result will show on the
     screen.</td></tr>
  <tr valign='top'><td>-a</td> <td>Take an asynchronous product. If this option is absent, this command will
     take a synchronous product.</td></tr>
  <tr valign='top'><td>-m</td> <td>Specify a map from the propositions of the second automaton to predicates
     on the propositions of the first automaton (or game).</td></tr>
</table></dd>
<dt>EXAMPLE</dt>
<dd><pre>  product -o c.gff a.gff b.gff
  product -m "a: p/\\q, b: q\\/r" a.gff b.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:promela'>- promela -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>promela - Convert a B&uuml;chi automaton into Promela code.</dd>

<dt>SYNOPSIS</dt>
  <dd>promela [-o FILE_OR_LVAL] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Convert a B&uuml;chi automaton into Promela code.<br/>
  <br/>
  <table><tr valign='top'><td>-o</td> <td>Output the Promela code to a file. By default, the Promela code will
     be displayed on the screen.</td></tr></table></dd>

<dt>EXAMPLE</dt>
  <dd>promela -o output input.gff</dd>
</dl>
    
<div><h3><a name='cmd:property'>- property -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>property - Get or set properties of an editable object such as automata.</dd>

<dt>SYNOPSIS</dt>
  <dd>property FILE_OR_LVAL [ EXPR [ EXPR ] ]</dd>

<dt>DESCRIPTION</dt>
  <dd>Get or set properties of an editable object. The first argument is the object.
  The second argument is the name of the property. The third argument is the
  new value of the property. If the third argument is absent, the current
  value of the property with the specified name will be returned. If both
  optional arguments are absent, all properties and their values will be
  returned.</dd>

<dt>EXAMPLE</dt>
<dd><pre>  property $aut Formula
  property $aut Description</pre></dd>
</dl>
    
<div><h3><a name='cmd:qptl'>- qptl -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>qptl - Manipulate QPTL formulae.</dd>

<dt>SYNOPSIS</dt>
  <dd>qptl [-f | -l | -p | -r EXPR EXPR] FORMULA</dd>

<dt>DESCRIPTION</dt>
  <dd>Manipulate QPTL formulae.<br/>
  <br/>
  <table><tr valign='top'><td>-f</td> <td>Get the free variables in a QPTL formula.</td></tr>
  <tr valign='top'><td>-l</td> <td>Get the length of a QPTL formula.</td></tr>
  <tr valign='top'><td>-p</td> <td>Check if a QPTL formula contains any past operator.</td></tr>
  <tr valign='top'><td>-r</td> <td>Rename a free variable in a QPTL formula. The first argument is an existing
     proposition and the second argument is a replacement of the existing
     proposition.</td></tr></table></dd>

<dt>EXAMPLE</dt>
  <dd><pre>qptl -l "[] p"</pre></dd>
</dl>
    
<div><h3><a name='cmd:readline'>- readline -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>readline - Read the input file line by line and put the results in a list.</dd>

<dt>SYNOPSIS</dt>
  <dd>readline FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Read the input file line by line and put the results in a list.</dd>

<dt>EXAMPLE</dt>
   <dd><pre>readline input.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:reduce'>- reduce -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>reduce - Remove unreachable and dead states from an automaton.</dd>

<dt>SYNOPSIS</dt>
  <dd>reduce [-o FILE_OR_LVAL | -u | -d ] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Given an automaton, remove the unreachable and dead states (if -u and -d are
  both present or both absent).<br/>
  <br/>
  <table><tr valign='top'><td>-o</td> <td>Output to a designated file. By default, the result will show on the
     screen.</td></tr>
  <tr valign='top'><td>-u</td> <td>Reduce only unreachable states.</td></tr>
  <tr valign='top'><td>-d</td> <td>Reduce only dead states.</td></tr></table></dd>

<dt>EXAMPLE</dt>
  <dd><pre>reduce -o b.gff a.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:replace'>- replace -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>replace - Replace matched substrings.</dd>

<dt>SYNOPSIS</dt>
  <dd>replace EXPR EXPR EXPR</dd>

<dt>DESCRIPTION</dt>
  <dd>Replace matched substrings. An automaton that recognizes the replacement
  results will be returned. The first argument is the source automaton (or
  regular expression), the second argument is the pattern automaton (or
  regular expression), and the third argument is the replacement automaton (or
  regular expression). If a string in the language of the source automaton
  contains substrings recognized by the pattern automaton, the matched
  substrings will be replaced by the strings recognized by the replacement
  automaton.</dd>

<dt>EXAMPLE</dt>
<dd><pre>  replace m1.gff m2.gff m3.gff
  replace m1.gff "a+" "c"</pre></dd>
</dl>
    
<div><h3><a name='cmd:repository'>- repository -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>repository - Access the local and remote repositories.</dd>

<dt>SYNOPSIS</dt>
  <dd>repository [-t EXPR | -min | -f EXPR] ("local" | "remote")</dd>

<dt>DESCRIPTION</dt>
  <dd>Access the automata or the formulae in the local repository or in the remote
  repository.<br/>
  <br/>
  <table><tr valign='top'><td>-t</td> <td>Specify the return type, either "automaton" or "formula". By default,
     pairs of a formula and an automaton will be returned.</td></tr>
  <tr valign='top'><td>-min</td> <td>Only return the smallest automata.</td></tr>
  <tr valign='top'><td>-f</td> <td>Search for a formula.</td></tr></table></dd>

<dt>EXAMPLE</dt>
<dd><pre>  repository -t automaton local
  repository -t formula remote</pre></dd>
</dl>
    
<div><h3><a name='cmd:reverse'>- reverse -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>reverse - Reverse a classic finite state automaton.</dd>

<dt>SYNOPSIS</dt>
  <dd>reverse [-o FILE_OR_LVAL] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Reverse a classic finite state automaton such that the output accepts the
  reverse of the language of the input.<br/>
  <br/>
  <table><tr valign='top'><td>-o</td> <td>Output to a designated file. By default, the result will show on the
     screen.</td></tr></table></dd>

<dt>EXAMPLE</dt>
  <dd><pre>reverse -o b.gff a.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:satisfiability'>- satisfiability -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>satisfiability - Check whether a formula is satisfiable.</dd>

<dt>SYNOPSIS</dt>
  <dd>satisfiability FORMULA_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Check whether the input formula is satisfiable. Return "true" if it is the
  case, and "false" otherwise.</dd>

<dt>EXAMPLE</dt>
  <dd><pre>satisfiability "(p U q) U ~q"</pre></dd>
</dl>
    
<div><h3><a name='cmd:save'>- save -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>save - Save an object to a file.</dd>

<dt>SYNOPSIS</dt>
  <dd>save [-c EXPR] LVAL FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Save an object to a file.<br/>
  <br/>
  <table><tr valign='top'><td>-c</td> <td>Specify the codec used to encode the object. By default, the GFF codec
     will be used.</td></tr></table></dd>
     
<dt>EXAMPLE</dt>
  <dd><pre>save $omega output.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:separation'>- separation -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>separation - Separate the past operators and the future operators in a QPTL
               formula.</dd>

<dt>SYNOPSIS</dt>
  <dd>separation FORMULA</dd>

<dt>DESCRIPTION</dt>
  <dd>Separate the past operators and the future operators in a QPTL formula. The
  formula is required to be convertible to prenex normal form.<br/>
  <br/>
  <table><tr valign='top'><td>-e</td> <td>Perform an equivalent rewrite such that the result is equivalent to the
     input formula. By default, a congruent rewrite is performed.</td></tr>
  <tr valign='top'><td>-plain</td> <td>Output formulae in plain text instead of GFF.</td></tr>
  <tr valign='top'><td>-spin</td> <td>Output formulae that can be accepted by SPIN.</td></tr></table></dd>

<dt>EXAMPLE</dt>
  <dd><pre>separation "[] (p --&gt; &lt;-&gt; q)"</pre></dd>
</dl>
    
<div><h3><a name='cmd:seq'>- seq -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>seq - Generate a sequence of numbers.</dd>

<dt>SYNOPSIS</dt>
  <dd>seq LAST</dd>
  <dd>seq FIRST LAST</dd>
  <dd>seq FIRST INCREMENT LAST</dd>

<dt>DESCRIPTION</dt>
  <dd>Generate a sequence of numbers. The LAST, FIRST, and INCREMENT
  in SYNOPSIS are all expressions.<br/></dd>

<dt>EXAMPLE</dt>
  <dd><pre>$numbers = seq 1 10</pre></dd>
</dl>
    
<div><h3><a name='cmd:simequiv'>- simequiv -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>simequiv - Check whether two automata are simulation equivalent.</dd>

<dt>SYNOPSIS</dt>
  <dd>simequiv EXPR EXPR</dd>

<dt>DESCRIPTION</dt>
  <dd>Check whether the two automata are simulation equivalent. Return "true" if it
  is the case, and "false" otherwise.</dd>

<dt>EXAMPLE</dt>
  <dd><pre>simequiv a.gff b.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:simplify'>- simplify -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>simplify - Simplify an automaton or a formula.</dd>

<dt>SYNOPSIS</dt>
  <dd>simplify [ -m EXPR | -o FILE_OR_LVAL | OPTIONS ] FILE_OR_LVAL</dd>

  <dd>Options for simulation:
    -dse | -ds | -rse | -rs | -ru | -rd</dd>

  <dd>Options for pruningfairset:
    -ifs | -rfs | -lfs | -t4 | -t5 | -t6 | -t7 | -t8 | -t9</dd>

<dt>DESCRIPTION</dt>
  <dd>Simplify the input automaton and return the resulting equivalent automaton
  of the same type, or simplify the input logic formula.<br/>
  <br/>
  <table><tr valign='top'><td>-m</td> <td>Specify the algorithm used for simplification. The value can be simulation,
     delayed, fair, pruningfairset, wring, or rabinindex. By default, simulation
     will be used.</td></tr>
  <tr valign='top'><td>-o</td> <td>Output to a designated file. By default, the result will show on the
     screen.</td></tr>
  <tr valign='top'><td>-dse</td> <td>Enable simplification by direct simulation equivalence.</td></tr>
  <tr valign='top'><td>-ds</td>  <td>Enable simplification by direct simulation.</td></tr>
  <tr valign='top'><td>-rse</td> <td>Enable simplification by reverse simulation equivalence.</td></tr>
  <tr valign='top'><td>-rs</td>  <td>Enable simplification by reverse simulation.</td></tr>
  <tr valign='top'><td>-ru</td>  <td>Enable reducing unreachable states.</td></tr>
  <tr valign='top'><td>-rd</td>  <td>Enable reducing dead states.</td></tr>
  <tr valign='top'><td>-ifs</td> <td>Enable pruning states not in the final set.</td></tr>
  <tr valign='top'><td>-rfs</td> <td>Enable pruning states not reaching the final set.</td></tr>
  <tr valign='top'><td>-lfs</td> <td>Enable pruning fair sets that contains another fair set of the final set.</td></tr>
  <tr valign='top'><td>-t4</td>  <td>Enable pruning fair sets by Theoram 4.</td></tr>
  <tr valign='top'><td>-t5</td>  <td>Enable pruning fair sets by Theoram 5.</td></tr>
  <tr valign='top'><td>-t6</td>  <td>Enable pruning fair sets by Theoram 6.</td></tr>
  <tr valign='top'><td>-t7</td>  <td>Enable pruning fair sets by Theoram 7.</td></tr>
  <tr valign='top'><td>-t8</td>  <td>Enable pruning fair sets by Theoram 8.</td></tr>
  <tr valign='top'><td>-t9</td>  <td>Enable pruning fair sets by Theoram 9.</td></tr></table></dd>

<dt>EXAMPLE</dt>
<dd><pre>  simplify -o b.gff a.gff
  simplify "[] [] p"</pre></dd>
</dl>
    
<div><h3><a name='cmd:simulated'>- simulated -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>simulated - Check whether the first automaton can be simulated by the
  second automaton.</dd>

<dt>SYNOPSIS</dt>
  <dd>simulated [-m EXPR] EXPR EXPR</dd>
  <dd>simulated -d EXPR EXPR</dd>
  <dd>simulated -f EXPR EXPR</dd>

<dt>DESCRIPTION</dt>
  <dd>Check whether the first automata can be simulated by the second automaton.
  Return "true" if it is the case, and "false" otherwise.

  <table><tr valign='top'><td>-m</td> <td>Specify the name of the simulation computation procedure.
     If this argument is absent, the default simulation procedure will be used.
     Use the command "names simulation2" to see all available procedures.</td></tr>
  <tr valign='top'><td>-d</td> <td>Use delayed simulation relation. If this argument is present, then both the
     automata should be B&uuml;chi automata.</td></tr>
  <tr valign='top'><td>-f</td> <td>Use fair simulation relation. If this argument is present, then both the
     automata should be B&uuml;chi automata.</td></tr></table></dd>

<dt>EXAMPLE</dt>
  <dd><pre>simulated a.gff b.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:sleep'>- sleep -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>sleep - Delay for a specified amount of time in seconds.</dd>

<dt>SYNOPSIS</dt>
  <dd>sleep EXPR</dd>

<dt>DESCRIPTION</dt>
  <dd>Delay for a specified amount of time in seconds.</dd>

<dt>EXAMPLE</dt>
  <dd><pre>reduce -o b.gff a.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:solve'>- solve -</a></h3></div>
<dl>

<dt>NAME</dt>
  <dd>solve - Solve a game and return a solution. The input game will be annotated
          with winning regions and winning strategies.</dd>

<dt>SYNOPSIS</dt>
  <dd>solve [ -m SOLVER ] [-g | -r | -s | -p PLAYER] [ SOLVER_SPECIFIC_ARGIMENTS ]
        FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Solve a game and return a map m where m["Game"] is a colored, annotated game
  and m[PLAYER_NAME] is the winning region and the winning strategy for the
  game player of the name PLAYER_NAME. The winning region and the winning
  strategy of a game player is also represented by a map w where
  w["WinningRegion"] is the winning region and w["WinningStrategy"] is the
  winning strategy. The name of the game player can be: P0, P1. If -g, -r, or
  -s is provided, only parts of the results will be returned.<br/>
  <br/>
  <table><tr valign='top'><td>-m</td> <td>Specify the name of the game solver. Available game solvers:
<ul>     <li>bigstep: an algorithm due to Schewe for parity games </li>
     <li>cb: a classical algorithm for Buchi games </li>
     <li>dominiondec: a deterministic subexponential algorithm based on dominion 
       decomposition for parity games </li>
     <li>globalopt: a generic solver with solver-independent global 
       optimizations for parity games </li>
     <li>mz: a recursive algorithm due to McNaughton-Zielonka for parity games </li>
     <li>reachability: an algorithm for reachability games </li>
     <li>recursive: a recursive algorithm due to Zielonka for parity games </li>
     <li>smallprog: an algorithm based on small progress measure for parity 
       games </li>  </ul></td></tr>
  <tr valign='top'><td>-g</td> <td>Return only the solved game.</td></tr>
  <tr valign='top'><td>-r</td> <td>Return only the winning regions.</td></tr>
  <tr valign='top'><td>-s</td> <td>Return only the winning strategies.</td></tr>
  <tr valign='top'><td>-p</td> <td>Return the winning region or the winning strategy only for the specified
     player. This option should be used with -r or -s.</td></tr></table></dd>

<dt>SOLVER globalopt</dt>
<dd>  <table><tr valign='top'><td>-solver</td> <td>Specify the delegated game solver.</td></tr>
  <tr valign='top'><td>-pp</td>     <td>Propagate parities of states. The default is off.</td></tr>
  <tr valign='top'><td>-pc</td>     <td>Compress parity conditions. The default is off.</td></tr>
  <tr valign='top'><td>-ps</td>     <td>Preprocess states with self-loops. The default is off.</td></tr>
  <tr valign='top'><td>-sd</td>     <td>Decompose the game into strongly-connected components. The default is
          off.</td></tr></table></dd>

<dt>SOLVER reachability</dt>
<dd>  <table><tr valign='top'><td>-max</td> <td>Maximize the strategies for both players. Disabled by default.</td></tr></table></dd>

<dt>EXAMPLE</dt>
<dd><pre>  solve game.gff
  solve -m mz game.gff</pre></dd>
</dl>

<div><h3><a name='cmd:split'>- split -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>split - Split an object into a set of elements.</dd>

<dt>SYNOPSIS</dt>
  <dd>split [-d STRING_OR_LVAL] [EXPR | CMD_EXPR]</dd>

<dt>DESCRIPTION</dt>
  <dd>If the object is a list, this command will return a set of list
  elements. If the object is an array, this command will return the
  key set of the array. Otherwise, this command will convert the object
  into a string and split the string according the delimiter. The default
  delimiter is spaces, tabs, and newlines.<br/>
  <br/>
  <table><tr valign='top'><td>-d</td> <td>Specify the delimiter.</td></tr></table></dd>

<dt>EXAMPLE</dt>
<dd><pre>  $keys = split $arr
  $elements = split -d ":" "1:2:3"</pre></dd>
</dl>
    
<div><h3><a name='cmd:stat'>- stat -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>stat - Get statistical data of an automaton or a QPTL formula.</dd>

<dt>SYNOPSIS</dt>
  <dd>stat [-s | -t | -a ] FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Get statistical data of an automaton or a QPTL formula. For automata, the
  statistical data include the number of states, the number of transitions, and
  the number of acceptance sets. For QPTL formulae, the statistical data include
  the number of alternations of past and future temporal operators.<br/>
  <br/>
  <table><tr valign='top'><td>-s</td> <td>Get the number of states only.</td></tr>
  <tr valign='top'><td>-t</td> <td>Get the number of transitions only.</td></tr>
  <tr valign='top'><td>-a</td> <td>Get the number of acceptance sets (or states) only.</td></tr></table></dd>

<dt>EXAMPLE</dt>
<dd><pre>  stat -s a.gff
  stat -t a.gff
  stat a.gff
  stat "[](p --&gt; &lt;-&gt; q)"</pre></dd>
</dl>
    
<div><h3><a name='cmd:test'>- test -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>test - Perform internal tests.</dd>

<dt>SYNOPSIS</dt>
  <dd>test ???</dd>

<dt>DESCRIPTION</dt>
  <dd>This command is for internal usage.</dd>
</dl>  
    
<div><h3><a name='cmd:translate'>- translate -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>translate - Translate a logic formula into an automaton.</dd>

<dt>SYNOPSIS</dt>
  <dd>translate [ RE | ORE | QPTL | ACTL ] [ -m TRANSLATE_ALG | -o FILE_OR_LVAL
            | -t AUTOMATON_TYPE | -sa | -se | -sf | -sg | -sb | -stgb | -sp
            | -si | -sr | -rbm | -dt | -mp | -art | -pi | -pe ] FORMULA_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Translate a logic formula into an automaton. By default, this command
  translates a QPTL formula into a non-deterministic B&uuml;chi word automaton.
  RE stands for regular expressions while ORE stands for &omega;-regular
  expressions. The translation for an ACTL formula produces a fair Kripke
  structure interpreted as a label-on-state automaton base on [PMT02].<br/>
  <br/>
  <table><tr valign='top'><td>-m</td> <td>Choose the translation algorithm (tableau, inctableau, temporaltester,
     gpvw, gpvw+, ltl2aut, ltl2aut+, ltl2ba, pltl2ba, couvreur, ltl2buchi,
     modella, kp02, ccj09, or qptl2ba). This option applies to QPTL translation
     only.
     By default, the tableau algorithm will be used.</td></tr>
  <tr valign='top'><td>-o</td> <td>Output to a designated file. By default, the result will show on the
     screen.</td></tr>
  <tr valign='top'><td>-t</td> <td>Choose the type of the target automaton (ngbw or nbw). This option applies
     to QPTL translation only. By default, it will be a non-deterministic
     B&uuml;chi word automaton (NBW).</td></tr>
  <tr valign='top'><td>-se</td> <td>Simplify the input (&omega;-)regular expression. By default, this option is
      off.</td></tr>
  <tr valign='top'><td>-sa</td> <td>Simplify the intermediate automata during the translation of &omega;-regular
      expressions. By default, this option is off.</td></tr>
  <tr valign='top'><td>-sf</td> <td>Simplify the input QPTL formula before translation. By default, this
       option is off.</td></tr>
  <tr valign='top'><td>-sg</td> <td>Simplify the intermediate NGBW during the translation. By default, this
      option is off</td></tr>
  <tr valign='top'><td>-sb</td> <td>Simplify the NBW during the translation. By default, this option is off.</td></tr>
  <tr valign='top'><td>-stgb</td> <td>Simplify the NTGBW by simulation. By default, this option is off.</td></tr>
  <tr valign='top'><td>-sp</td> <td>Simplify the NBW after projecting quantifiers. By default, this option
      is off.</td></tr>
  <tr valign='top'><td>-si</td> <td>Simplify intermediate NBW during translation. By default, this option
      is off.</td></tr>
  <tr valign='top'><td>-sr</td> <td>Apply superset reduction to the generalized B&uuml;chi acceptance condition.
      By default, this option is off.</td></tr>
  <tr valign='top'><td>-rbm</td> <td>Reduce dead states before merging equivalent NBW states if the algorithm
       is LTL2BA. By default, this option is off.</td></tr>
  <tr valign='top'><td>-dt</td> <td>Delegate the translation of unquantified formulae to another translation
      algorithm. By default, this option is off.</td></tr>
  <tr valign='top'><td>-mp</td> <td>Minimize the automata of past formulae for QPTL2BA. By default, this
      option is off.</td></tr>
  <tr valign='top'><td>-art</td> <td>Apply advanced reduction of NTGBW transitions during the conversion from
       two-way VWAA for PLTL2BA. By default, this option is off.</td></tr>
  <tr valign='top'><td>-pi</td> <td>Apply prime implicants to simplify covers for LTL2AUT+. By default, this
       option is off.</td></tr>
  <tr valign='top'><td>-pe</td> <td>Apply postponed expansion of refined states for GPVW, LTL2AUT, LTL2AUT+,
      MoDeLLa, LTL2Buchi, and Couvreur. By default, this  option is off.</td></tr>
  <tr valign='top'><td>-ru</td> <td>Reduce unreachable states of label-on-state NGBW obtained by Tableau. By
      default, this  option is off.</td></tr>
  <tr valign='top'><td>-rd</td> <td>Reduce dead states of label-on-state NGBW obtained by Tableau. By default,
      this  option is off.</td></tr></table></dd>

<dt>EXAMPLE</dt>
<dd><pre>  translate -m gpvw -t nbw -o Fp.gff "&lt;&gt;p"
  translate ORE "(a|b)* { b }"</pre></dd>
</dl>
    
<div><h3><a name='cmd:union'>- union -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>union - Compute the union of the two input automata.</dd>

<dt>SYNOPSIS</dt>
  <dd>union [-o FILE_OR_LVAL] FILE_OR_LVAL FILE_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Compute the union of the two input automata and output the resulting
  automaton.<br/>
  <br/>
  <table><tr valign='top'><td>-o</td> <td>Output to a designated file. By default, the result will show on the
     screen.</td></tr></table></dd>

<dt>EXAMPLE</dt>
  <dd><pre>union -o c.gff a.gff b.gff</pre></dd>
</dl>
    
<div><h3><a name='cmd:validity'>- validity -</a></h3></div>

<dl>
<dt>NAME</dt>
  <dd>validity - Check whether a formula is valid.</dd>

<dt>SYNOPSIS</dt>
  <dd>validity FORMULA_OR_LVAL</dd>

<dt>DESCRIPTION</dt>
  <dd>Check whether the input formula is valid. Return "true" if it is the case,
  and "false" otherwise.</dd>

<dt>EXAMPLE</dt>
  <dd><pre>validity "[](p U q) U q &lt;--&gt; p U q"</pre></dd>
</dl>
    



<!-- ======================================================- -->
<!--          Generated Command Description (End)             -->
<!-- ======================================================- -->



<!-- ================== Extending GOAL ================== -->

<h1><a name="extending_goal">Extending GOAL</a></h1>

<p class="plain">
GOAL uses <a href="http://jpf.sourceforge.net/">Java Plugin Framework</a>
(JPF) to export extension points and thus several GOAL functions can be
extended.
This document does not provide a tutorial on writing plugins and extensions.
For the readers that are interested in extending GOAL, they are encouraged
to visit the JPF website.
</p>

<h2>GOAL Libraries</h2>

When the user wants to extend GOAL, the development environment should include
GOAL classes as libraries.
To do this, the user may use the script <i>mklib</i> or <i>mklib.bat</i> to build GOAL
libraries.
The created GOAL libraries will be placed in the <i>lib</i> directory.

<h2>Codecs</h2>

<p class="plain">
The codecs can be extended by implementing the interface
<a href="api/org/svvrl/goal/core/io/Codec.html"><code>Codec</code></a>.
A codec is an encoder, a decoder, or both.
An encoder is capable of encoding a QPTL formula, a finite state automaton,
an alternating automaton, a game, or other kinds of objects to a file.
A decoder is capable of decoding a file back to an object supported by GOAL.
</p>

<h3>Extension Point Declaration</h3>

<pre>&lt;extension-point id="Codec"&gt;
  &lt;parameter-def id="class" /&gt;
  &lt;parameter-def id="priority" type="number" /&gt;
&lt;/extension-point&gt;
</pre>

<dl>
<dt>class</dt>
<dd>The class implementing <code>Codec</code>.</dd>
<dt>priority</dt>
<dd>
  When there are more than one codecs supporting an object,
  the codec with a highest priority (lower number) will be used if not
  specified.
</dd>
</dl>

<h2>Command-Line Commands</h2>

<p class="plain">
The command-line commands can be extended by extending 
<a href="api/org/svvrl/goal/cmd/CommandExpression.html"><code>CommandExpression</code></a>
or implementing the interface
<a href="api/org/svvrl/goal/cmd/CommandExtension.html"><code>CommandExtension</code></a>.
Basically, an object of <a href="api/org/svvrl/goal/cmd/CommandExpression.html"><code>CommandExpression</code></a>
represents an invocation of the provided command (together with the arguments for the command),
that is, roughly the cmd_expr in <a href="#cmd:grammar">Grammar</a>.
More precisely, a cmd_expr corresponds to an object of
<a href="api/org/svvrl/goal/cmd/CommandExecutor.html"><code>CommandExecutor</code></a>,
which is used as a wrapper of a command.
When an object of <a href="api/org/svvrl/goal/cmd/CommandExecutor.html"><code>CommandExecutor</code></a> is evaluated,
it evaluates the runtime arguments specified by --option, instantiates the underlying command with all the arguments, and
then evaluates the underlying command. 
</p>

<p class="plain">
An object of <a href="api/org/svvrl/goal/cmd/CommandExtension.html"><code>CommandExtension</code></a> provides
meta-information (command name, full name, and help message) about the provided command. 
Since static meta-information can be written in plugin.xml,
<a href="api/org/svvrl/goal/cmd/CommandExtension.html"><code>CommandExtension</code></a> is used mainly when
the meta-information contains dynamic contents that are known at runtime.
</p>

<p class="plain">
The class extending <a href="api/org/svvrl/goal/cmd/CommandExpression.html"><code>CommandExpression</code></a>
must have a constructor taking a list of <a href="api/org/svvrl/goal/cmd/Expression.html"><code>Expression</code></a>
as the only argument, and implement the function <a href="api/org/svvrl/goal/cmd/Expression.html#eval-org.svvrl.goal.cmd.Context-"><code>eval</code></a>.
</p>

<p class="plain">
An implement of <a href="api/org/svvrl/goal/cmd/CommandExtension"><code>CommandExtension</code></a>
must have a constructor taking no parameter and should provide the class of the provided command,
the unique command name, the full name, and the help message either in the class itself or in plugin.xml. 
</p>

<h3>Extension Point Declaration</h3>

<pre>&lt;extension-point id="CommandExpression"&gt;
  &lt;parameter-def id="class" /&gt;
  &lt;parameter-def id="name" /&gt;
  &lt;parameter-def id="full name" multiplicity="none-or-one" /&gt;
  &lt;parameter-def id="help" /&gt;
&lt;/extension-point&gt;
</pre>

<dl>
<dt>class</dt>
<dd>The class extending <code>CommandExpression</code>.</dd>
<dt>name</dt>
<dd>The unique command name.</dd>
<dt>full name</dt>
<dd>The full name to be displayed as the title of the provided command in help messages.</dd>
<dt>help</dt>
<dd>The help message of the provided command.</dd>
</dl>

<pre>&lt;extension-point id="CommandExtension"&gt;
  &lt;parameter-def id="class" /&gt;
  &lt;parameter-def id="name" /&gt;
  &lt;parameter-def id="full name" multiplicity="none-or-one" /&gt;
  &lt;parameter-def id="help" multiplicity="none-or-one" /&gt;
&lt;/extension-point&gt;
</pre>

<dl>
<dt>class</dt>
<dd>The class implementing <code>CommandExtension</code>.</dd>
<dt>name</dt>
<dd>The unique command name.</dd>
<dt>full name</dt>
<dd>The full name to be displayed as the title of the provided command in help messages.</dd>
<dt>help</dt>
<dd>The help message of the provided command.</dd>
</dl>

<h3>Constructions Supported by Complement Command</h3>

<p class="plain">
See <a href="#cmd:complement_construction_interface">here</a> for more details.
</p>

<h3>Solvers Supported by Solve Command</h3>

<p class="plain">
See <a href="#cmd:game_solver_interface">here</a> for more details.
</p>

<h2>Complement Construction</h2>

<p class="plain">
The complementation constructions for containment and equivalence testing can be
extended by extending
<a href="api/org/svvrl/goal/core/comp/ComplementConstruction.html"><code>ComplementConstruction</code></a>.
The implementation must have a constructor taking a single parameter that extends
<a href="api/org/svvrl/goal/core/aut/Automaton.html"><code>Automaton</code></a>.
The complementation constructions extended can be found in
<a href="api/org/svvrl/goal/core/comp/ComplementRepository.html"><code>ComplementRepository</code></a>.
</p>

<p class="plain" id="cmd:complement_construction_interface">
The complementation constructions available for the
<a href="#cmd:complement">complement</a> command can be extended by adding a 
<a href="api/org/svvrl/goal/cmd/ComplementConstructionInterface.html"><code>ComplementConstructionInterface</code></a>
object to <a href="api/org/svvrl/goal/cmd/CommandRepository.html"><code>CommandRepository</code></a>
via <code>CommandRepository.addComplementConstructionInterface(ComplementConstructionInterface)</code>.
If the interface object provides the default construction for a type of automata, it should be added by
<code>CommandRepository.addComplementConstructionInterface(ComplementConstructionInterface, AutomatonType)</code>. 
The interface object must provide a unique name for the provided construction, a help message, and the class of
the provided construction either directly in the object or in plugin.xml.

Note that some common arguments (see <a href="api/org/svvrl/goal/cmd/ComplementExpression.html"><code>ComplementExpression</code></a>)
will be consumed before being passed to the interface object.
</p>

<h3>Extension Point Declaration</h3>

<pre>&lt;extension-point id="ComplementConstruction"&gt;
  &lt;parameter-def id="class" /&gt;
  &lt;parameter-def id="name" /&gt;
&lt;/extension-point&gt;
</pre>

<dl>
<dt>class</dt>
<dd>The class implementing <code>ComplementConstruction</code>.</dd>
<dt>name</dt>
<dd>The name of this complementation construction.</dd>
</dl>

<p class="plain">
The extension point of complementation constructions for the
<a href="#cmd:complement">complement</a> command is described below.  
</p>

<pre>
&lt;extension-point id="ComplementConstructionInterface">
  &lt;parameter-def id="class" />
  &lt;parameter-def id="default for" multiplicity="none-or-one" /&gt;
  &lt;parameter-def id="name" multiplicity="none-or-one" /&gt;
  &lt;parameter-def id="construction" multiplicity="none-or-one" /&gt;
  &lt;parameter-def id="help" multiplicity="none-or-one" /&gt;
&lt;/extension-point&gt;
</pre>

<dl>
<dt>class</dt>
<dd>The class implementing <code>ComplementConstructionInterface</code>.</dd>
<dt>default for</dt>
<dd>Set the provided construction the default for the specified type of automata.</dd>
<dt>name</dt>
<dd>The name of the provided complementation construction.</dd>
<dt>construction</dt>
<dd>The class path of the provided complementation construction.</dd>
<dt>help</dt>
<dd>The help message.</dd>
</dl>


<h2>Console Handlers</h2>

<h2>Cost Functions</h2>

<h2>Drawers</h2>

<h2>Editable</h2>

<h2>Editors</h2>

<h2>Formula Rewriter</h2>

<h2>Game Solvers</h2>

<p class="plain">
The game solvers can be extended by implementing the interface
<a href="api/org/svvrl/goal/core/aut/game/GameSolver.html"><code>GameSolver</code></a>.
The implementation must have a constructor taking no parameter.
Once a game solver is plugged, it can be accessed by methods in 
<a href="api/org/svvrl/goal/core/aut/game/GameSolverRepository.html"><code>GameSolverRepository</code></a>
or by the <a href="#menu:solve">Solve</a> menu item in the graphical user
interface.
</p>

<p class="plain" id="cmd:game_solver_interface">
To make the <a href='#cmd:solve'>solve</a> command-line command support a game
solver, a class implementing
<a href="api/org/svvrl/goal/cmd/GameSolverInterface.html"><code>GameSolverInterface</code></a>
is required.
A <code>GameSolverInterface</code> provides an interface between the
command-line arguments and a game solver, and it can configure the game
solver based on specified command-line arguments.
</p>

<h3>Extension Point Declaration</h3>

<p class="plain">
For the core package and the gui package,
</p>

<pre>&lt;extension-point id="GameSolver"&gt;
  &lt;parameter-def id="class" /&gt;
  &lt;parameter-def id="acc" /&gt;
&lt;/extension-point&gt;
</pre>

<dl>
<dt>class</dt>
<dd>The class implementing <code>GameSolver</code>.</dd>
<dt>acc</dt>
<dd>The class of the acceptance condition supported by the game solve.</dd>
</dl>

<p class="plain">
For the command-line package,
</p>

<pre>&lt;extension-point id="GameSolverInterface"&gt;
  &lt;parameter-def id="class" /&gt;
  &lt;parameter-def id="name" /&gt;
  &lt;parameter-def id="solver" /&gt;
  &lt;parameter-def id="description" /&gt;
  &lt;parameter-def id="help" /&gt;
&lt;/extension-point&gt;
</pre>

<dl>
<dt>class</dt>
<dd>The class implementing <code>GameSolverInterface</code>.</dd>
<dt>name</dt>
<dd>A unique name of the game solver. This name will be used in the
<a href='cmd:solve'>solve</a> command-line command</dd>
<dt>solver</dt>
<dd>The class implementing <a href="api/org/svvrl/goal/core/aut/game/GameSolver.html"><code>GameSolver</code></a>.</dd>
<dt>description</dt>
<dd>A simple description about the provided solver. The description will be displayed in the help message of the <a href="#cmd:solve">solve</a> command.</dd>
<dt>help</dt>
<dd>The help message of the provided solver.</dd>
</dl>

<h2>Layout Algorithms</h2>

<p class="plain">
The layout algorithms can be extended by implementing the interface
<a href="api/org/svvrl/goal/core/layout/Layout.html"><code>Layout</code></a>.
The implementation must have a constructor taking no parameter.
</p>

<h3>Extension Point Declaration</h3>

<pre>&lt;extension-point id="Layout"&gt;
  &lt;parameter-def id="class" /&gt;
  &lt;parameter-def id="name" /&gt;
  &lt;parameter-def id="mnemonic" multiplicity="none-or-one" /&gt;
  &lt;parameter-def id="tooltip" multiplicity="none-or-one" /&gt;
&lt;/extension-point&gt;
</pre>

<dl>
<dt>class</dt>
<dd>The class implementing <code>Layout</code>.</dd>
<dt>name</dt>
<dd>The name of this layout algorithm.</dd>
<dt>mnemonic</dt>
<dd>The mnemonic of the menu item for this layout algorithm.</dd>
<dt>tooltip</dt>
<dd>The tooltip text of the menu item for this layout algorithm.</dd>
</dl>

<h2>Menu</h2>

<p class="plain">
The menu and menu items can be extended by extending
<a href="api/org/svvrl/goal/gui/menu/UIMenu.html"><code>UIMenu</code></a> and
<a href="api/org/svvrl/goal/gui/action/WindowAction.html"><code>WindowAction</code></a>.
The implementation must have a constructor taking a single
<a href="api/org/svvrl/goal/gui/Window.html"><code>Window</code></a> parameter.
</p>

<h3>Extension Point Declaration</h3>

<pre>&lt;extension-point id="Menu"&gt;
  &lt;parameter-def id="class" /&gt;
  &lt;parameter-def id="container" /&gt;
  &lt;parameter-def id="location" /&gt;
  &lt;parameter-def id="name" multiplicity="none-or-one" /&gt;
  &lt;parameter-def id="mnemonic" multiplicity="none-or-one" /&gt;
  &lt;parameter-def id="accelerator" multiplicity="none-or-one" /&gt;
  &lt;parameter-def id="tooltip" multiplicity="none-or-one" /&gt;
  &lt;parameter-def id="small_icon" multiplicity="none-or-one" /&gt;
  &lt;parameter-def id="large_icon" multiplicity="none-or-one" /&gt;
  &lt;parameter-def id="style" multiplicity="none-or-one" /&gt;
  &lt;parameter-def id="group" multiplicity="none-or-one" /&gt;
  &lt;parameter-def id="separator" type="boolean" multiplicity="none-or-one" /&gt;
&lt;/extension-point&gt;
</pre>

<dl>
<dt>class</dt>
<dd>
  The class implementing <code>UIMenu</code> or <code>WindowAction</code>.
  If this class does not exist, a default <code>UIMenu</code> object will be
  created.
</dd>
<dt>container</dt>
<dd>
  The container of this <code>UIMenu</code> or <code>WindowAction</code>,
  represented by the container's canonical class name.
  For example, a top menu in the menu bar is in the container
  <a href="api/org/svvrl/goal/gui/MenuBar.html"><code>org.svvrl.goal.gui.MenuBar</code></a>.
</dd>
<dt>location</dt>
<dd>
  The location of this <code>UIMenu</code> or <code>WindowAction</code> in its
  container.
  A location can be "first", "after=class", "before=class", or "last" where
  class is the canonical class name of its sibling.
</dd>
<dt>name</dt>
<dd>The name of this <code>UIMenu</code> or <code>WindowAction</code>.</dd>
<dt>mnemonic</dt>
<dd>The mnemonic of this <code>UIMenu</code> or <code>WindowAction</code>.</dd>
<dt>accelerator</dt>
<dd>
  The accelerator of this <code>UIMenu</code> or <code>WindowAction</code>.
</dd>
<dt>tooltip</dt>
<dd>
  The tooltip text of this <code>UIMenu</code> or <code>WindowAction</code>.
</dd>
<dt>small_icon</dt>
<dd>
  The small icon of this <code>UIMenu</code> or <code>WindowAction</code>.
</dd>
<dt>large_icon</dt>
<dd>
  The large icon of this <code>UIMenu</code> or <code>WindowAction</code>.
</dd>
<dt>style</dt>
<dd>
  The visual style of this <code>WindowAction</code>.
  Possible values are "button", "check", and "radio" representing
  <code>JMenuItem</code>, <code>JCheckBoxMenuItem</code>, and
  <code>JRadioButtonMenuItem</code> respectively. 
</dd>
<dt>group</dt>
<dd>The button group of this <code>WindowAction</code>.</dd>
<dt>separator</dt>
<dd>
  True if there should be a separator before this <code>UIMenu</code> or
  <code>WindowAction</code>.
</dd>
</dl>

<h2>Preference Panels</h2>

<h2>Property Editors</h2>

<h2>Toolboxes</h2>

<h2>UI Handlers</h2>

<!-- ================== Terminology ================== -->

<h1><a name="terminology">Terminology</a></h1>

<h2><a name="terminology:b">A</a></h2>

<dl>
<dt><a name="terminology:actl">ACTL (&forall;CTL)</a></dt>
<dd>
  &forall; Computational Tree Logic
</dd>
</dl>

<h2><a name="terminology:b">B</a></h2>

<dl>
<dt><a name="terminology:bfs">BFS</a></dt>
<dd>
  Breadth-First Search
</dd>
</dl>

<h2><a name="terminology:d">D</a></h2>

<dl>
<dt>DBW</dt>
<dd>Deterministic B&uuml;chi Word Automaton</dd>
<dt>DCW</dt>
<dd>Deterministic Co-B&uuml;chi Word Automaton</dd>
<dt><a name="terminology:dead_state">Dead State</a></dt>
<dd>
  A state is <i>dead</i> if it does not occur in any accepting run.
</dd>
<dt><a name="terminology:dfs">DFS</a></dt>
<dd>
  Depth-First Search
</dd>
<dt>DFW (DFA)</dt>
<dd>Deterministic Classic Finite Word Automaton</dd>
<dt>DGBW</dt>
<dd>Deterministic Generalized B&uuml;chi Word Automaton</dd>
<dt>DMW</dt>
<dd>Deterministic Muller Word Automaton</dd>
<dt>DPW</dt>
<dd>Deterministic Parity Word Automaton</dd>
<dt>DRW</dt>
<dd>Deterministic Rabin Word Automaton</dd>
<dt>DSW</dt>
<dd>Deterministic Streett Word Automaton</dd>
</dl>

<h2><a name="terminology:l">L</a></h2>

<dl>
<dt><a name="terminology:ltl">LTL</a></dt>
<dd>
  Linear Temporal Logic
</dd>
</dl>

<h2><a name="terminology:n">N</a></h2>

<dl>
<dt>NABW</dt>
<dd>Nondeterministic Alternating B&uuml;chi Word Automaton</dd>
<dt>NACW</dt>
<dd>Nondeterministic Alternating Co-B&uuml;chi Word Automaton</dd>
<dt>NAGBW</dt>
<dd>Nondeterministic Alternating Generalized B&uuml;chi Word Automaton</dd>
<dt>NAMW</dt>
<dd>Nondeterministic Alternating Muller Word Automaton</dd>
<dt><a name="terminology:napw">NAPW</a></dt>
<dd>Nondeterministic Alternating Parity Word Automaton</dd>
<dt>NARW</dt>
<dd>Nondeterministic Alternating Rabin Word Automaton</dd>
<dt>NASW</dt>
<dd>Nondeterministic Alternating Streett Word Automaton</dd>

<dt>NBW</dt>
<dd>Nondeterministic B&uuml;chi Word Automaton</dd>
<dt>NCW</dt>
<dd>Nondeterministic Co-B&uuml;chi Word Automaton</dd>
<dt>NFW (NFA)</dt>
<dd>Nondeterministic Classic Finite Word Automaton</dd>
<dt>NGBW</dt>
<dd>Nondeterministic Generalized B&uuml;chi Word Automaton</dd>
<dt>NMW</dt>
<dd>Nondeterministic Muller Word Automaton</dd>
<dt>NPW</dt>
<dd>Nondeterministic Parity Word Automaton</dd>
<dt>NRW</dt>
<dd>Nondeterministic Rabin Word Automaton</dd>
<dt>NSW</dt>
<dd>Nondeterministic Streett Word Automaton</dd>

<dt>NTBW</dt>
<dd>Nondeterministic Transition B&uuml;chi Word Automaton</dd>
<dt>NTCW</dt>
<dd>Nondeterministic Transition Co-B&uuml;chi Word Automaton</dd>
<dt>NTGBW</dt>
<dd>Nondeterministic Transition Generalized B&uuml;chi Word Automaton</dd>
<dt>NTMW</dt>
<dd>Nondeterministic Transition Muller Word Automaton</dd>
<dt>NTPW</dt>
<dd>Nondeterministic Transition Parity Word Automaton</dd>
<dt>NTRW</dt>
<dd>Nondeterministic Transition Rabin Word Automaton</dd>
<dt>NTSW</dt>
<dd>Nondeterministic Transition Streett Word Automaton</dd>
</dl>

<h2><a name="terminology:p">P</a></h2>

<dl>
<dt><a name="terminology:ptl">PTL</a></dt>
<dd>
  Propositional Temporal Logic
</dd>
</dl>

<h2><a name="terminology:q">Q</a></h2>

<dl>
<dt><a name="terminology:qptl">QPTL</a></dt>
<dd>
  Quantified Propositional Temporal Logic, which subsumes LTL
</dd>
</dl>

<h2><a name="terminology:u">U</a></h2>

<dl>
<dt><a name="terminology:ucbw">UCBW</a></dt>
<dd>
  Universal Co-B&uuml;chi Word Automaton, NACW in CNF
</dd>
<dt><a name="terminology:unreachable_state">Unreachable State</a></dt>
<dd>
  A state is <i>unreachable</i> if it cannot be reached from the initial state.
</dd>
</dl>

<h2><a name="terminology:v">V</a></h2>

<dl>
<dt><a name="terminology:vwaa">VWAA</a></dt>
<dd>Very Weak Alternating Automaton</dd>
</dl>

<!-- ================== References ================== -->

<h1><a name="references">References</a></h1>

<dl>

<!-- A -->
<dt><a name="references:atw06">ATW06</a></dt>
<dd>
  Christoph Schulte Althoff, Wolfgang Thomas and Nico Wallmeier. Observations
  on determinization of B&uuml;chi automata. Theoretical Computer Science,
  363(2):224-233, 2006.
</dd>

<!-- B -->
<dt><a name="references:bk09">BK09</a></dt>
<dd>
  Udi Boker and Orna Kupferman. Co-ing B&uuml;chi Made Tight and Useful.
  In Proceedings of the 24th Annual IEEE Symposium on Logic in
  Computer Science (LICS), pages 245-254. IEEE Computer Society, 2009.
</dd>

<dt><a name="references:buc62">Buc62</a></dt>
<dd>
  J. Richard B&uuml;chi. On a Decision Method in Restricted Second Order
  Arithmetic. In Congress on Logic, Method, and Philosophy of Science 1960.
  Logical Methods in Computer Science, 5(1), 2009.
</dd>

<!-- C -->
<dt><a name="references:ccj09">CCJ09</a></dt>
<dd>
  Jacek Cicho&#x0144; and Adam Czubak and Andrzej Jasi&#x0144;ski.
  Minimal B&uuml;chi Automata for Certain Classes of LTL Formulas.
  In Proceedings of the Fourth International Conference on Dependability
  of Computer Systems (DepCoS-RELCOMEX), pages 17-24. IEEE Computer Society,
  2009.
</dd>
<dt><a name="references:cm99">CM99</a></dt>
<dd>
  Olivier Carton, Ram&oacute;n Maceiras. Computing the Rabin Index of a Parity
  Automaton. In Informatique Th&eacute;orique et Applications (ITA),
  33(6):495-506, 1999.
</dd>
<dt><a name="references:cmp92">CMP92</a></dt>
<dd>
  Edward Y. Chang, Zohar Manna, Amir Pnueli. Characterization of Temporal
  Property Classes. In Automata, Languages and Programming (ICALP),
  LNCS 623, pages 474-486. Springer, 1992.
</dd>
<dt><a name="references:cou99">Cou99</a></dt>
<dd>
  Jean-Michel Couvreur. On-the-Fly Verification of Linear Temporal Logic.
  In World Congress on Formal Methods (FM), LNCS 1708, pages 253-271.
  Springer, 1999. 
</dd>

<!-- D -->
<dt><a name="references:dg08">DG08</a></dt>
<dd>
  Volker Diekert and Paul Gastin.
  First-order definable languages.
  Logic and Automata, volume 2 of Texts in Logic and Games,
  pages 261-306, 2008.
</dd>
<dt><a name="references:dgv99">DGV99</a></dt>
<dd>
  Marco Daniele, Fausto Giunchiglia and Moshe Y. Vardi. Improved Automata
  Generation for Linear Temporal Logic. In Computer Aided Verification (CAV),
  LNCS 1633, pages 249-260. Springer, 1999. 
</dd>
<dt><a name="references:dh96">DH96</a></dt>
<dd>
  Ron Davidson and David Harel. Drawing Graphs Nicely Using Simulated
  Annealing. ACM Transactions on Graphics, 15(4):301-331, 1996.
</dd>
<dt><a name="references:wdmr08">WDMR08</a></dt>
<dd>
  Martin De Wulf, Laurent Doyen, Nicolas Maquet, Jean-François Raskin.
  Antichains: Alternative Algorithms for LTL Satisfiability and Model-Checking.
  In Tools and Algorithms for the Construction and Analysis of Systems (TACAS),
  LNCS 4963, pages 63-77. Springer, 2008.
</dd>


 
<!-- E --> 
<dt><a name="references:eh00">EH00</a></dt>
<dd>
  Kousha Etessami and Gerard J. Holzmann. Optimizing B&uuml;chi Automata.
  In Concurrency Theory (CONCUR), LNCS 1877, pages 153-167. Springer, 2000.
</dd>
<dt><a name="references:el92">EL92</a></dt>
<dd>
  Peter Eades and Wei Lai. Algorithms for Disjoint Node Images. In Australasian
  Computer Science Conference (ACSC), pages 253-265. 1992.
</dd>
<dt><a name="references:ews01">EWS01</a></dt>
<dd>
  Kousha Etessami, Thomas Wilke, and Rebecca A. Schuller.
  Fair Simulation Relations, Parity Games, and State Space Reduction for
  B&uuml;chi Automata.
  In International Colloquium on Automata, Languages and Programming (ICALP),
  LNCS 2076, pages 694-707. Springer, 2001.
</dd>

<!-- F -->
<dt><a name="references:far94">Far02</a></dt>
<dd>
  Berndt Farwer. &omega;-Automata. In Automata, Logics, and Infinite Games:
  A Guide to Current Research. LNCS 2500, pages 3-20, Springer Verlag, 2002. 
</dd>
<dt><a name="references:fl09">FL09</a></dt>
<dd>
  Oliver Friedmann and Martin Lange. Solving Parity Games in Practice.
  In Automated Technology for Verification and Analysis (ATVA), LNCS 5799,
  pages 182-196. Springer, 2009. 
</dd>
<dt><a name="references:flm94">FLM94</a></dt>
<dd>
  Arne Frick, Andreas Ludwig and Heiko Mehldau. A Fast Adaptive Layout
  Algorithm for Undirected Graphs. In Graph Drawing (GD), LNCS 894, pages
  388-403. Springer, 1994. 
</dd>
<dt><a name="references:fr91">FR91</a></dt>
<dd>
  Thomas M. J. Fruchterman and Edward M. Reingold. Graph Drawing by
  Force-directed Placement. Software: Practice and Experience,
  21(11):1129-1164, 1991.
</dd>

<!-- G -->
<dt><a name="references:gab87">Gab87</a></dt>
<dd>
  Dov M. Gabbay. The Declarative Past and Imperative Future: Executable
  Temporal Logic for Interactive Systems. In Temporal Logic in Specification,
  LNCS 398, pages 409-448. Springer, 1987.
</dd>
<dt><a name="references:gbs02">GBS02</a></dt>
<dd>
  Sankar Gurumurthy, Roderick Bloem, and Fabio Somenzi.
  Fair Simulation Minimization.
  In Computer Aided Verification (CAV), LNCS 2404, pages 610-624.
  Springer, 2002.
</dd>
<dt><a name="references:gl94">GL94</a></dt>
<dd>
  Orna Grumberg and David E. Long. Model Checking and Modular Verification.
  ACM Transactions on Programming Languages and Systems (TOPLAS), 16(3):
  843-871, 1994.
</dd>
<dt><a name="references:gl02">GL02</a></dt>
<dd>
  Dimitra Giannakopoulou and Flavio Lerda. From States to Transitions:
  Improving Translation of LTL Formulae to B&uuml;chi Automata. In Formal
  Techniques for Networked and Distributed Systems (FORTE), LNCS 2529,
  pages 308-326. Springer, 2002.
</dd>
<dt><a name="references:go01">GO01</a></dt>
<dd>
  Paul Gastin and Denis Oddoux. Fast LTL to B&uuml;chi Automata Translation. In
  Computer Aided Verification (CAV), LNCS 2102, pages 53-65. Springer, 2001. 
</dd>
<dt><a name="references:go03">GO03</a></dt>
<dd>
  Paul Gastin and Denis Oddoux. LTL with Past and Two-Way Very-Weak Alternating
  Automata. In Mathematical Foundations of Computer Science (MFCS), LNCS 2747,
  pages 439-448. Springer, 2003. 
</dd>
<dt><a name="references:gpss80">GPSS80</a></dt>
<dd>
  Dov M. Gabbay, Amir Pnueli, Saharon Shelah and Jonathan Stavi. On the
  Temporal Analysis of Fairness. In ACM SIGPLAN-SIGACT Symposium on Principles
  of Programming Languages (POPL), pages 163-173, 1980.
</dd>
<dt><a name="references:gpvw95">GPVW95</a></dt>
<dd>
  Rob Gerth, Doron Peled, Moshe Y. Vardi, and Pierre Wolper. Simple
  on-the-fly Automatic Verification of Linear Temporal Logic. In Protocol
  Specification, Testing, and Verification (PSTV), pages 3-18. Chapman &amp; Hall,
  1995.
</dd>

<!-- H -->
<dt><a name="references:hhk95">HHK95</a></dt>
<dd>
  Monika Rauch Henzinger, Thomas A. Henzinger, Peter W. Kopke.
  Computing Simulations on Finite and Infinite Graphs.
  In Foundations of Computer Science (FOCS), pages 453-462.
  IEEE Computer Society, 1995:
  453-462
</dd>

<dt><a name="references:himf98">HIMF98</a></dt>
<dd>
  Kunihiko Hayashi, Michiko Inoue, Toshimitsu Masuzawa and Hideo Fujiwara.
  A Layout Adjustment Problem for Disjoint Rectangles Preserving Orthogonal
  Order. In Graph Drawing (GD), LNCS 1547, pages 183-197. Springer, 1998.
</dd>
<dt><a name="references:himf02">HIMF02</a></dt>
<dd>
  Kunihiko Hayashi, Michiko Inoue, Toshimitsu Masuzawa and Hideo Fujiwara.
  A Layout Adjustment Problem for Disjoint Rectangles Preserving Orthogonal
  Order. Systems and Computers in Japan, 33(2):31-42, 2002.
</dd>
<dt><a name="references:hl03">HL03</a></dt>
<dd>
  Xiaodi Huang and Wei Lai. Force-Transfer: A New Approach to Removing
  Overlapping Nodes in Graph Layout. In Australasian Computer Science
  Conference (ACSC), CRPIT 16, pages 349-358. Australian Computer Society,
  2003. 
</dd>
<dt><a name="references:hlsg07">HLSG07</a></dt>
<dd>
  Xiaodi Huang, Wei Lai, A. S. M. Sajeev and Junbin Gao. A New Algorithm for
  Removing Node Overlapping in Graph Visualization. Information Sciences,
  177(14):2821-2844, 2007.
</dd>
<dt><a name="references:hop71">Hop71</a></dt>
<dd>
  John Hopcroft. An n log n algorithm for minimizing states in a finite automaton.
  In Theory of Machines and Computations, pages 186-196. Academic Press, 1971.
  177(14):2821-2844, 2007.
</dd>

<!-- J -->
<dt><a name="references:joh75">Joh75</a></dt>
<dd>
  Donald B. Johnson.
  Finding all the Elementary Circuits of a Directed Graph.
  SIAM Journal on Computing, 4(1):77-84, 1975.
</dd>

<dt><a name="references:jpz06">JPZ06</a></dt>
<dd>
  Marcin Jurdzi&#x0144;ski, Mike Paterson, and Uri Zwick.
  A Deterministic Subexponential Algorithm for Solving Parity Games.
  Journal on Computing, 38(4):1519-1532, 2008.
</dd>
<dt><a name="references:jur00">Jur00</a></dt>
<dd>
  Marcin Jurdzi&#x0144;ski. Small Progress Measures for Solving Parity Games.
  In Symposium on Theoretical Aspects of Computer Science (STACS), LNCS 1770,
  pages 290-301. Springer, 2000.
</dd>

<!-- K -->     
<dt><a name="references:kb06">KB06</a></dt>
<dd>
  Joachim Klein and Christel Baier. Experiments with deterministic
  &omega;-automata for formulas of linear temporal logic. 
  Theoretical Computer Science, 363(2):182-195, 2006.
</dd>
<dt><a name="references:kk89">KK89</a></dt>
<dd>
  Tomihisa Kamada and Satoru Kawai. An Algorithm for Drawing General
  Undirected Graphs. Information Processing Letters, 31:7-15, 1989.
</dd>
<dt><a name="references:kmmp93">KMMP93</a></dt>
<dd>
  Yonit Kesten, Zohar Manna, Hugh McGuire, and Amir Pnueli. A Decision
  Algorithm for Full Propositional Temporal Logic. In Computer Aided
  Verification (CAV), LNCS 697, pages 97-109. Springer, 1993.
</dd>
<dt><a name="references:kp00">KP00</a></dt>
<dd>
  Yonit Kesten and Amir Pnueli. Verification by Augmented Finitary
  Abstraction. Information and Computation, 163(1):203-243, 2000.
</dd>
<dt><a name="references:kp02">KP02</a></dt>
<dd>
  Yonit Kesten and Amir Pnueli. Complete Proof System for QPTL.
  Journal of Logic and Computation, 12(5):701-745, 2002.
</dd>
<dt><a name="references:kur87">Kur87</a></dt>
<dd>
  Robert P. Kurshan. Complementing Deterministic B&uuml;chi Automata in
  Polynomial Time. Journal of Computer and System Sciences (JCCS),
  35(1): 59-71, 1987.
</dd>
<dt><a name="references:kus01">Kus01</a></dt>
<dd>
  Ralf Küsters. Memoryless Determinacy of Parity Games.
  In Automata, Logics, and Infinite Games, LNCS 2500,
  pages 95-106. Springer 2001.
</dd>
<dt><a name="references:kv01">KV01</a></dt>
<dd>
  Orna Kupferman and Moshe Y. Vardi. Weak Alternating Automata are not that
  Weak. ACM Transactions on Computational Logic (TOCL), 2(3):408-429, 2001.
</dd>
<dt><a name="references:kw08">KW08</a></dt>
<dd>
  Detlef K&auml;hler and Thomas Wilke. Complementation, Disambiguation, and
  Determinization of B&uuml;chi Automata Unified. In International Colloquium
  on Automata, Languages and Programming (ICALP), LNCS 5125, pages 724-735.
  Springer, 2008.
</dd>

<!-- L -->
<dt><a name="references:lan69">LAN69</a></dt>
<dd>
  Lawrence H. Landweber. Decision Problems for &omega;-Automata. Mathematical
  Systems Theory, 3(4):376-384, 1969.
</dd>
<dt><a name="references:le98">LE98</a></dt>
<dd>
  Wei Lai and Peter Eades. Routing Drawings in Diagram Displays. In 
  Asian Pacific Computer and Human Interaction (APCHI), pages 291-297. IEEE
  Computer Society, 1998. 
</dd>

<!-- M -->

<dt><a name="references:mcn93">McN93</a></dt>
<dd>
  Robert McNaughton. Infinite Games Played on Finite Graphs.
  Annals of Pure and Applied Logic, 65(2): 149-184, 1993.
</dd>
<dt><a name="references:mels95">MELS95</a></dt>
<dd>
  Kazuo Misue, Peter Eades, Wei Lai and Kozo Sugiyama. Layout Adjustment and
  the Mental Map. Journal of Visual Languages and Computing, 6(2):183-210,
  1995.
</dd>
<dt><a name="references:mey98">Mey98</a></dt>
<dd>
  Bernd Meyer. Self-Organizing Graphs - A Neural Network Perspective of Graph
  Layout. In Graph Drawing (GD), LNCS 1547, pages 246-262. Springer, 1998.
</dd>
<dt><a name="references:mh84">MH84</a></dt>
<dd>
  Satoru Miyano and Takeshi Hayashi. Alternating Finite Automata on &omega;-Words.
  Theoretical Computer Science, 32(3), 321-330, 1984.
</dd>
<dt><a name="references:moo56">Moo56</a></dt>
<dd>
  Edward F. Moore. Gedanken-experiments on sequential machines. In Automata
  Studies, Annals of Mathematics Studies, no. 34, pages 129–153.
  Princeton University Press, 1956.
</dd>
<dt><a name="references:mp90">MP90</a></dt>
<dd>
  Zohar Manna and Amir Pnueli. A Hierarchy of Temporal Properties. In Proceedings
  of the 9th Annual ACM Symposium on Principles of Distributed Computing (PODC),
  pages 377-410. ACM, 1990.
</dd>
<dt><a name="references:mp92">MP92</a></dt>
<dd>
  Zohar Manna and Amir Pnueli. The Temporal Logic of Reactive and Concurrent
  Systems. Springer, 1992.
</dd>
<dt><a name="references:mp95">MP95</a></dt>
<dd>
  Zohar Manna and Amir Pnueli. Temporal Verification of Reactive Systems:
  Safety. Springer, 1995.
</dd>
<dt><a name="references:ms95">MS95</a></dt>
<dd>
  David E. Muller and Paul E. Schupp. Simulating Alternating Tree Automata by
  Nondeterministic Automata: New Results and New Proofs of the Theorems of
  Rabin, McNaughton and Safra. Theoretical Computer Science, 141(1&amp;2):69-107,
  1995.
</dd>

<!-- P -->
<dt><a name="references:pit06">Pit06</a></dt>
<dd>
  Nir Piterman. From Nondeterministic B&uuml;chi and Streett Automata to
  Deterministic Parity Automata. In Logic in Computer Science (LICS),
  pages 255-264. IEEE Computer Society, 2006.
</dd>
<dt><a name="references:pmt02">PMT02</a></dt>
<dd>
  Hong Peng, Yassine Mokhtari, and Sofi&egrave;ne Tahar. Environment Synthesis
  for Compositional Model Checking. In Computer Design (ICCD), pages 70-75.
  IEEE Computer Society, 2002.
</dd>

<!-- S -->
<dt><a name="references:saf88">Saf88</a></dt>
<dd>
  Shmuel Safra. On the Complexity of &omega;-Automata. In Foundations of
  Computer Science (FOCS), pages 319-327. IEEE Computer Society, 1988.
</dd>
<dt><a name="references:sb00">SB00</a></dt>
<dd>
  Fabio Somenzi and Roderick Bloem. Efficient B&uuml;chi Automata from LTL
  Formulae. In Computer Aided Verification (CAV), LNCS 1855, pages 248-263.
  Springer, 2000. 
</dd>
<dt><a name="references:sch07">Sch07</a></dt>
<dd>
  Sven Schewe. Solving Parity Games in Big Steps. In Foundations of Software
  Technology and Theoretical Computer Science (FSTTCS), LNCS 4855, pages
  449-460. Springer, 2007.
</dd>
<dt><a name="references:sch09a">Sch09a</a></dt>
<dd>
  Sven Schewe. B&uuml;chi Complementation Made Tight. In Symposium on
  Theoretical Aspects of Computer Science (STACS), pages 661-672. 2009.
</dd>
<dt><a name="references:sch09b">Sch09b</a></dt>
<dd>
  Sven Schewe. Tighter Bounds for the Determinisation of B&uuml;chi Automata.
  In Symposium on Foundations of Software Science and Computational Structures (FOSSACS),
  LNCS 5504, pages 167-181. 2009.
</dd>
<dt><a name="references:st03">ST03</a></dt>
<dd>
  Roberto Sebastiani and Stefano Tonetta: "More Deterministic" vs. "Smaller"
  B&uuml;chi Automata for Efficient LTL Model Checking. In Correct Hardware
  Design and Verification Methods (CHARME), LNCS 2860, pages 126-140.
  Springer, 2003. 
</dd>
<dt><a name="references:svw87">SVW87</a></dt>
<dd>
  A. Prasad Sistla, Moshe Y. Vardi and Pierre Wolper. The Complementation
  Problem for B&uuml;chi Automata with Applications to Temporal Logic.
  Theoretical Computer Science, 49:217-237, 1987.
</dd>

<!-- T -->
<dt><a name="references:tct07">TCT+07</a></dt>
<dd>
  Yih-Kuen Tsay, Yu-Fang Chen, Ming-Hsien Tsai, Kang-Nien Wu, Wen-Chin Chan.
  GOAL: A Graphical Tool for Manipulating B&uuml;chi Automata and Temporal
  Formulae. In Tools and Algorithms for the Construction and Analysis of
  Systems (TACAS), LNCS 4424, pages 466-471. Springer, 2007.
</dd>
<dt><a name="references:tct08">TCT+08</a></dt>
<dd>
  Yih-Kuen Tsay, Yu-Fang Chen, Ming-Hsien Tsai, Wen-Chin Chan and Chi-Jian Luo.
  GOAL Extended: Towards a Research Tool for Omega Automata and Temporal Logic.
  In Tools and Algorithms for the Construction and Analysis of Systems (TACAS),
  LNCS 4963, pages 346-350. Springer, 2008.
</dd>
<dt><a name="references:tfvt10">TFVT10</a></dt>
<dd>
  Ming-Hsien Tsai, Seth Fogarty, Moshe Y. Vardi, and Yih-Kuen Tsay.
  State of B&uuml;chi Complementation. In Implementation and Application of
  Automata (CIAA), LNCS 6482, pages 261-271. Springer, 2010.
</dd>
<dt><a name="references:tho99">Tho99</a></dt>
<dd>
  Wolfgang Thomas. Complementation of B&uuml;chi Automata Revisited. Jewels are
  Forever 1999: 109-12.
</dd>
<dt><a name="references:ttcc11">TTCC11</a></dt>
<dd>
  Yih-Kuen Tsay, Ming-Hsien Tsai, Jinn-Shu Chang, Yi-Wen Chang.
  B&uuml;chi Store: An Open Repository of B&uuml; Automata.
  In Tools and Algorithms for the Construction and Analysis of Systems (TACAS),
  LNCS 6605, pages 262-266. Springer, 2011.
</dd>
<dt><a name="references:ttcc13">TTCC13</a></dt>
<dd>
  Yih-Kuen Tsay, Ming-Hsien Tsai, Jinn-Shu Chang, Yi-Wen Chang, and Chi-Shiang Liu.
  B&uuml;chi Store: An Open Repository of &omega;-Automata.
  Software Tools for Technology Transfer (STTT), 15(2):109-123. 2013.
</dd>
<dt><a name="references:tth13">TTH13</a></dt>
<dd>
  Ming-Hsien Tsai, Yih-Kuen Tsay, and Yu-Shiang Hwang.
  GOAL for Games, Omega-Automata, and Logics.
  In Computer Aided Verification (CAV),
  LNCS 8044, pages 883-889. Springer, 2013.
</dd>

<!-- V -->
<dt><a name="references:vw07">VW07</a></dt>
<dd>
  Moshe Y. Vardi and Thomas Wilke. Automata: from Logics to Algorithms. In
  Logic and Automata: History and Perspective, volume 2 of Texts in Logic and
  Games, pages 629-736. Amsterdam University Press, 2007.
</dd>

<!-- Y -->

<dt><a name="references:ybci08">YBCI08</a></dt>
<dd>
  Fang Yu, Tevfik Bultan, Marco Cova, and Oscar H. Ibarra.
  Symbolic String Verification: An Automata-Based Approach.
  In SPIN, LNCS 5156, pages 306-324. Springer, 2008.
</dd>

<!-- Z -->
<dt><a name="references:zie98">Zie98</a></dt>
<dd>
  Wieslaw Zielonka. Infinite Games on Finitely Coloured Graphs with
  Applications to Automata on Infinite Trees. Theoretical Computer Science,
  200(1-2):135-183, 1998.
</dd>



</dl>

<!--
<dt><a name="references:"></a></dt>
<dd>
</dd>
-->

</div>

</body>

</html>
